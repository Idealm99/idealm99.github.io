---
layout: single
title:  "C++ 4차 보고서"
categories: C++
toc: true
toc_sticky: true
author_profile: false
---
# 10장 객체와 클래스

1. 객체 지향 프로그래밍(OOP)은 프로그램 설계 방법 중 하나이다.
2. C++은 객체 지향 프로그래밍을 쉽게 구현할 수 있도록 만든 프로그래밍 언어이다.
3. OOP의 가장 중요한 기능은 추상화, 캡슐화, 다형성, 상속, 코드의 재활용이다.
4. 클래스는 이러한 기능들을 구현하고 결합하는 데 사용되는 가장 중요한 C++ 도구이다.

핵심 요약:

* OOP는 프로그램 설계 방법 중 하나이다.
* C++은 OOP를 쉽게 구현할 수 있도록 만든 프로그래밍 언어이다.
* OOP의 가장 중요한 기능은 추상화, 캡슐화, 다형성, 상속, 코드의 재활용이다.
* 클래스는 이러한 기능들을 구현하고 결합하는 데 사용되는 가장 중요한 C++ 도구이다.

| 기능 | 설명 | 예시 |
|---|---|---|
| 추상화(abstraction) | 복잡한 개념을 간단한 개념으로 표현하는 것 | 컴퓨터에서 파일은 복잡한 데이터 구조이지만, 사용자에게는 파일 이름과 크기만 보여준다. |
| 캡슐화(encapsulation) | 객체의 상태와 행동을 하나로 묶는 것 | 자동차 클래스는 엔진, 변속기, 바퀴 등과 같은 상태와 주행, 정지, 회전 등과 같은 행동을 하나로 묶는다. |
| 다형성(polymorphism) | 하나의 함수 이름으로 여러 가지 종류의 인자를 처리하는 것 | `print()` 함수는 문자열, 숫자, 리스트 등과 같은 다양한 인자를 처리할 수 있다. |
| 상속(inheritance) | 기존의 클래스를 재사용하여 새로운 클래스를 만드는 것 | `Car` 클래스는 `Vehicle` 클래스를 상속받아 자동차의 특성을 구현한다. |
| 코드의 재활용(reusability of code) | 기존의 코드를 재사용하여 새로운 코드를 작성하는 것 | `로그인` 함수는 기존의 `로그인` 코드를 재사용하여 새로운 `로그인` 코드를 작성할 수 있다. |

이러한 객체 지향 프로그래밍의 기능들은 소프트웨어 개발의 효율성을 높이고, 유지보수성을 향상시키는 데 도움이 됩니다.

## 10.1 절차식 프로그래밍과 객체 지향 프로그래밍

| 절차적 프로그래밍 | 객체 지향 프로그래밍 |
|---|---|
| 명령을 순차적으로 실행한다. | 객체를 중심으로 코드를 작성한다. |
| 함수를 중심으로 코드를 작성한다. | 객체는 데이터와 함수를 하나로 묶는다. |
| 복잡한 프로그램에 적합하지 않다. | 복잡한 프로그램에 적합하다. |
| 이해하기 쉽고, 코드를 작성하기 쉽다. | 코드를 유지보수하기 쉽고, 확장하기 쉽다. |
| C, C++ 등과 같은 언어에서 주로 사용된다. | Java, Python, C# 등과 같은 언어에서 주로 사용된다. |

## 10.2 추상화와 클래스

추상화는 복잡한 개념을 단순한 개념으로 표현하는 것을 의미합니다. 

클래스는 추상화의 한 형태로, 데이터와 함수를 하나로 묶어 객체를 생성합니다.

클래스를 사용하면 객체의 상태와 행동을 한 번에 정의할 수 있어 코드의 재사용성과 유지보수성을 향상시킬 수 있습니다.

### 데이터형이란 무엇인가

데이터형은 메모리에 저장되는 형태 뿐만 아니라 그것을 대상으로 수행할 수 있는 연산에 의해 정의됩니다.

int형은 사칙연산, 나머지 연산자까지 사용 가능하지만 포인터는 int형에 적용할 수 있는 연산을 허용하지 않습니다.

어떤 변수를 선언한다고 할 때 단지 메모리 대입이 아닌 그 데이터형이 수행할 수 있는 연산도 함께 정의 된다는 것입니다.


쉽게 말해 기본형을 서술하는 것은 다음과 같은 세 가지를 결정하는 것입니다.

* 데이터 객체에 필요한 메모리의 크기
* 메모리에 있는 비트들을 어떻게 해석할 것인지
* 데이터 객체를 사용하여 수행할 수 있는 연산이나 메소드

내장된 기본 데이터형은 동작에 관한 정보가 컴파일러에 내장됩니다.

그러나 사용자 정의 데이터형은 이와 같은 정보를 직접 제공해야 합니다.

### C++ 의 클래스

클래스는 추상화를 사용자 정의 데이터형으로 변환해 주는 수단이다 

쿨래스는 데이터 표현과 데이터를 조작하는 메서드들을 하나의 패키지 안에 결합한다.

클래스 서술 두 부분

> 클래스 선언 : 데이터형 멤버와 public 인터페이스 멤버 함수를 이용하여 데이터 표현을 서술
> 클래스 메서드 정의 : 클래스 맴버 함수가 어떻게 구현되는지를 서술

클래스 선언 방법

```c++
class World
{
 float mass;   // private 디폴트
 char name[20];   // private 디폴트
public :
 void tellall(void);
};
```
클래스 선언 끝에 ; 를 붙이고 class 다음 클래스의 이름을 적는다.

아무런 제한자가 없으면 private가 디폴트 값이다.

###  클래스 맴버 함수의 구현

1. 클래스 멤버 함수 정의:
   - 클래스 내부에서 선언한 멤버 함수를 정의할 때에는 사용 범위 결정 연산자(::)를 사용합니다.
   - 사용 범위 결정 연산자를 사용하여 어느 클래스에 속한 멤버 함수인지 명시합니다.
   - 예시: `void Stock::update(double price)`

2. 클래스 메서드의 접근 제한:
   - 클래스 내에서 선언한 멤버 함수는 해당 클래스의 private 부분에서만 접근 가능합니다.

3. 함수 머리에서 사용 범위 결정 연산자 사용:
   - 함수 머리에서도 사용 범위 결정 연산자를 사용하여 어느 클래스에 속한 함수인지 명시합니다.

4. 같은 이름의 멤버 함수 사용:
   - 다른 클래스에 속해 있는 멤버 함수도 동일한 함수 이름을 사용할 수 있습니다.
   - 사용 범위 결정 연산자를 통해 함수가 어느 클래스에 속하는지 명시합니다.

5. 클래스 메서드가 private 멤버에 접근 가능:
   - 클래스 멤버 함수는 해당 클래스의 private 멤버에도 접근할 수 있습니다.

6. show() 메서드 예시:
   - show() 메서드를 예시로 들면, 해당 메서드에서 private 데이터 멤버인 company, shares, share_val, total_val에 접근하여 출력할 수 있습니다.
   - `cout`를 사용하여 private 데이터 멤버 값을 출력할 수 있습니다.

```
cout << "회사명: " << company
     << " 주식 수: " << shares << endl
     << " 주가: $" << share_val
     << " 주식 총 가치: $" << total_val << endl;
```
### 클래스 사용하기

클래스 변수를 선언함으로써 또는 클래스형의 객체를 대입하기 위해 new를 이용함으로써 클래스를 사용할 수 있다.

또한 객체를 매개변수로 전달할 수 있고 함수의 리턴값으로 리턴할 수 있다.

아래의 프로그램은 stock이라는 Stock 객체를 하나 생성한다.

```cpp
// usestock0.cpp -- Stock 클래스를 사용한 주식 거래 시뮬레이션 프로그램
// stock00.cpp와 컴파일하여 실행합니다.

#include <iostream>
#include "stock00.h" // Stock 클래스의 선언을 포함하는 헤더 파일을 포함

int main()
{
    Stock fluffy_the_cat; // Stock 클래스의 객체 생성
    fluffy_the_cat.acquire("NanoSmart", 20, 12.50); // 주식 정보를 초기화
    fluffy_the_cat.show(); // 주식 정보 출력

    fluffy_the_cat.buy(15, 18.125); // 15주를 18.125 달러에 구매
    fluffy_the_cat.show(); // 주식 정보 출력

    fluffy_the_cat.sell(400, 20.00); // 보유 주식보다 많은 주식을 매도하려 해서 거래 취소됨
    fluffy_the_cat.show(); // 주식 정보 출력

    fluffy_the_cat.buy(300000, 40.125); // 300000주를 40.125 달러에 구매
    fluffy_the_cat.show(); // 주식 정보 출력

    fluffy_the_cat.sell(300000, 0.125); // 300000주를 0.125 달러에 매도
    fluffy_the_cat.show(); // 주식 정보 출력

    return 0;
}
```
출력.

```cpp
회사명: NanoSmart 주식수: 20
 주가: $12.5 주식 총 가치: $250
회사명: NanoSmart 주식수: 35
 주가: $18.125 주식 총 가치: $634.375
보유 주식보다 많은 주식을 매도할 수 없으므로, 거래가 취소되었습니다.
회사명: NanoSmart 주식수: 35
 주가: $18.125 주식 총 가치: $634.375
회사명: NanoSmart 주식수: 300035
 주가: $40.125 주식 총 가치: $1.20389e+07
회사명: NanoSmart 주식수: 35
 주가: $0.125 주식 총 가치: $4.375
```
### 실행상의 변경

프로그램의 결과가 일관적이지 않은 숫자 양식으로 인해 사용자를 곤혹스럽게 하는 경우가 있을 수 있다.

인터페이스를 변경하지 않고 문제를 개선하는 방법이 있다

ostream 클래스는 양식을 컨트롤하는 맴버 함수를 지녔다. setf()를 사용함으로써 표기상의 문제를 피할 수 있다.

```cpp
std::cout.self(std::ios_base::fixed, std::ios_base::floatfield);
```
이 코드는 플래그를 고정 소수점 표기를 사용하기 위해 cout 개체 안에 플래그를 세팅한다

이와 유사한 방법으로 

```cpp
std::cout.precision(3);
```
고정 소수점 표기를 사용할 때 자리 수를 지정할 수 있다.

이 방법들은 표기 양식을 컨트롤하기 위해서 show() 메서드에서 사용될 수 있으나 

프로그램의 다른 부분에 영향을 주지 않도록 해야한다.

show()가 호출되기 이전의 상태로 정보를 리셋하는 것이 안정된 사용법이다.

```cpp
// 출력 스트림(std::cout)의 소수점 자릿수를 3으로 설정하고, 이전 설정 값을 'prec' 변수에 저장합니다.
std::streamsize prec = std::cout.precision(3);

// 여기에 다양한 작업 및 출력 수행

// 'prec' 변수에 저장된 이전 소수점 자릿수 설정을 복원합니다.
std::cout.precision(prec);

// 'std::ios_base::fixed' 포맷 플래그를 사용하여 출력 형식을 고정 소수점 표기로 설정하고,
// 이전 설정 값을 'orig' 변수에 저장합니다.
std::ios_base::fmtflags orig = std::cout.setf(std::ios_base::fixed);

// 여기에 다양한 작업 및 출력 수행

// 'orig' 변수에 저장된 이전 포맷 플래그 설정을 복원하여 출력 형식을 이전 설정으로 되돌립니다.
std::cout.setf(orig, std::ios_base::floatfield);

```
orig는 모든 플래그를 보유하고 있으며

리셋 구문은 그 정보를 사용하여 고정 소수점 표기와 과학적 기수법을 위한 플래그를 포함하고 있는 floatfield에 있는 정보를 리셋한다.

### 지금까지의 설명 요약

1. 클래스 설계를 서술하는 첫 번째 단계는 클래스 선언을 제공하는 것이다.

> 클래스 선언은 private , public 부분을 가진다
> public은 인터페이스로 private는 데이터 은닉,캡슐화를 하는데 사용된다.

2. 클래스 설계를 서술하는 두 번째 단계는 클래스 맴버 함수를 구현한다.

## 10.3 클래스 생성자와 파괴자

아래는 생성자와 파괴자의 개념을 표로 정리한 것입니다.

| 개념          | 생성자 (Constructor)                      | 파괴자 (Destructor)                        |
| ------------- | ---------------------------------------- | ----------------------------------------- |
| 역할          | 객체 초기화                              | 객체 해제 및 정리 작업                      |
| 호출 시점      | 객체 생성 시 자동 호출                   | 객체 소멸 시 자동 호출                     |
| 이름          | 클래스 이름과 동일                       | 클래스 이름 앞에 `~` 기호를 붙인 형태        |
| 반환 타입      | 반환값 없음 (void)                        | 반환값 없음 (void)                         |
| 인자          | 생성자는 매개변수를 받아 초기화            | 파괴자는 매개변수 없음                    |
| 호출 여부     | 명시적으로 호출하지 않고, 객체 생성 시 자동 호출 | 명시적으로 호출하지 않고, 객체 소멸 시 자동 호출 |
| 주요 용도     | 객체 초기화, 멤버 변수 설정, 리소스 할당 등 | 리소스 해제, 정리 작업, 메모리 누수 방지 등 |
| 중복 정의 가능 | 여러 개의 생성자 중복 정의 가능           | 단 하나의 파괴자만 정의 가능                |
| 상속          | 기본 및 파생 클래스에서 생성자 재정의 가능 | 기본 및 파생 클래스에서 파괴자 재정의 가능 |


아래는 예시 코드입니다.

```ccp
#include <iostream>
#include <string>

class Stock {
private:
    std::string company;
    int shares;
    double share_val;
    double total_val;

    // 멤버 함수 내에서 사용되는 private 메서드
    void set_total() { total_val = shares * share_val; }

public:
    // 생성자: 객체를 초기화하는 역할을 합니다.
    Stock(const std::string &co, int n, double pr) {
        company = co;
        shares = n;
        share_val = pr;
        set_total();
    }

    // 소멸자: 객체가 소멸될 때 자원을 해제하는 역할을 합니다.
    ~Stock() {
        std::cout << "주식 " << company << "의 객체가 소멸됨!" << std::endl;
    }

    void acquire(const std::string &co, int n, double pr);
    void buy(int num, double price);
    void sell(int num, double price);
    void update(double price);
    void show();
};

// 멤버 함수의 정의

void Stock::acquire(const std::string &co, int n, double pr) {
    company = co;
    if (n < 0) {
        std::cout << "주식 수는 음수일 수 없습니다. 거래가 취소되었습니다." << std::endl;
        shares = 0;
    } else {
        shares = n;
    }
    share_val = pr;
    set_total();
}

void Stock::buy(int num, double price) {
    if (num < 0) {
        std::cout << "주식 수는 음수일 수 없습니다. 거래가 취소되었습니다." << std::endl;
    } else {
        shares += num;
        share_val = price;
        set_total();
    }
}

void Stock::sell(int num, double price) {
    if (num < 0) {
        std::cout << "주식 수는 음수일 수 없습니다. 거래가 취소되었습니다." << std::endl;
    } else if (num > shares) {
        std::cout << "보유 주식보다 많은 주식을 매도할 수 없습니다. 거래가 취소되었습니다." << std::endl;
    } else {
        shares -= num;
        share_val = price;
        set_total();
    }
}

void Stock::update(double price) {
    share_val = price;
    set_total();
}

void Stock::show() {
    std::cout << "회사명: " << company
              << " 주식 수: " << shares
              << " 주가: $" << share_val
              << " 주식 총 가치: $" << total_val << std::endl;
}

int main() {
    // 생성자를 통해 객체 생성 및 초기화
    Stock fluffy_the_cat("NanoSmart", 20, 12.50);
    // 위 코드와 같지만 다른 형식
    // Stock fluffy_the_cat = Stock("NanoSmart", 20, 12.50);
    // Stock *fluffy_the_cat = new Stock("NanoSmart", 20, 12.50);

    fluffy_the_cat.show();

    fluffy_the_cat.buy(15, 18.125);
    fluffy_the_cat.show();

    fluffy_the_cat.sell(400, 20.00);
    fluffy_the_cat.show();

    fluffy_the_cat.buy(300000, 40.125);
    fluffy_the_cat.show();

    fluffy_the_cat.sell(300000, 0.125);
    fluffy_the_cat.show();

    // main 함수 끝: fluffy_the_cat 객체가 범위를 벗어나면 소멸자가 호출됩니다.
    return 0;
}

```

클래스 안에 private는 클래스 안의 맴버 안에서만 접근이 가능하므로 생성자를 만들어서 접근할 수 있다.

## 10.4 객체 들여다보기, this 포인터

하나의 메서드가 두 개의 객체를 동시에 처리할 필요가 있다 그것을 가능하게 하기 위해서 this라는 

특별한 포인터를 제공한다.

하나의 메서드가 두 개의 객체를 동시에 처리할 필요한 경우의 예시입니다.

1. **게임에서 충돌 검사(Collision Detection)**:
   두 개의 게임 객체(예: 캐릭터와 적, 총알과 벽)가 서로 충돌했는지 여부를 판별하는 메서드가 필요한 경우가 있습니다. 두 객체의 위치, 크기 등을 비교하여 충돌 여부를 확인하고 게임 상태를 업데이트할 수 있습니다.

2. **금융 애플리케이션에서 거래 처리**:
   금융 거래를 처리할 때 두 개의 계좌 객체가 관련될 수 있습니다. 송금이나 이체와 같은 거래를 처리하는 메서드는 두 계좌의 잔액을 갱신하고 거래 내역을 기록하는 역할을 수행할 수 있습니다.

3. **그래픽 애플리케이션에서 객체 위치 업데이트**:
   그래픽 애플리케이션에서 두 개의 객체가 움직일 때, 객체 간의 상호작용이 필요한 경우가 있습니다. 예를 들어, 두 개의 객체가 서로 영향을 주거나 받아 움직이는 상황에서 두 객체의 위치를 동기화하는 메서드를 사용할 수 있습니다.

4. **사용자 관리 시스템에서 권한 검사**:
   사용자와 리소스(파일, 폴더 등) 간의 권한을 검사할 때 두 개의 객체가 관련될 수 있습니다. 사용자 객체와 리소스 객체를 비교하여 사용자의 접근 권한을 확인하는 메서드를 구현할 수 있습니다.

5. **소셜 미디어 애플리케이션에서 친구 관계 확인**:
   소셜 미디어 애플리케이션에서 두 사용자(친구) 간의 관계를 확인할 때, 두 사용자 객체를 비교하여 친구 여부를 판별하는 메서드를 사용할 수 있습니다.

* this 포인터에 관한 지문

1. 비교할 두 개의 객체를 그 맴버 함수에 어떤 방법으로 제공할 것인가?
topval() 메서드가 const Stock & 형의 매개변수를 사용하도록 할 수 있다.

2. 그 메서드의 응답을 호출 프로그램에 어떤 방법으로 알릴 것인가?
둘 중 주식 가치가 더 큰 객체에 대한 참조를 그 메서드가 리턴하게 하는 것
메서드의 원형은
const Stock & topval ( const Stock & s ) const;

이 함수는 한 객체에는 암시적으로 접근 다른 한 객체에는 명시적으로 접근한다
그러고 나서 두 객체 중의 하나에 대한 참조를 리턴한다 const는 객체를 변경하지 않는다는 의미다

```cpp
top = stock1.topval(stock2);
top = stock2.topval(stock1);
```
두개는 같은 의미다

```cpp
#include <iostream>
#include <string>

class Stock {
private:
    std::string company;
    int shares;
    double share_val;
    double total_val;

    void set_total() {
        total_val = shares * share_val;
    }

public:
    Stock(const std::string &co, int n, double pr) {
        company = co; // 명시적인 this 포인터 사용 없이 멤버 변수에 직접 접근
        shares = n;
        share_val = pr;
        set_total();
    }

    void update(double price) {
        share_val = price; // 명시적인 this 포인터 사용 없이 멤버 변수에 직접 접근
        set_total();
    }

    void show() {
        std::cout << "회사명: " << company
                  << " 주식 수: " << shares
                  << " 주가: $" << share_val
                  << " 주식 총 가치: $" << total_val << std::endl;
    }
};

int main() {
    Stock stock1("NanoSmart", 20, 12.50);

    stock1.update(15.0);
    stock1.show();

    return 0;
}
```

위 코드에서 co price 같은 부분이 this포인터를 이용하여 

현재 객체의 멤버 변수와 메서드에 접근하는 모습을 볼 수 있다. 암시적으로 표현한 것이며 명시적으로 

this -> company = co; 이렇게 표현도 가능하다.

## 10.5 객체 배열

```
Stock my[4]; // 4개의 Stock 객체로 이루어진 배열을 생성
```

명시적으로 초기화되지 않은 클래스 객체들을 생성할 때 프로그램은 항상 디폴트 클래스 생성자(public)를 호출한다

생성자를 사용하여 배열 원소들을 초기화할 수 있다. 그러면 각각의 원소에 대해 생성자를 호출해야 한다.

예시 코드로
```cpp
const int STRS = 5;
Stock stocks [STKS] = {
stock ("Nanosmart", 12.5, 20),
stock("Boffo Objects", 200, 2.0),
stock ("Monolithic obelisks", 130, 3.25),
Stock ("Fleep Enterprises", 60, 6.5)
};
```
여기서 남은 하나의 생성자는 디폴트 생성자를 사용하여 초기화한다.

## 10.6 클래스 사용 범위



| 접근 범위  | 외부에서 접근 가능 여부 | 파생 클래스에서 접근 가능 여부 | 내부 접근 가능 여부 |
|------------|-----------------------|-------------------------|-------------------|
| `public`   | 가능                  | 가능                    | 가능              |
| `protected`| 불가능                | 가능                    | 가능              |
| `private`  | 불가능                | 불가능                  | 가능              |

* 예시 코드


1. `public` 접근 범위:

```cpp
#include <iostream>

class PublicExample {
public:
    int public_var;

    void PublicMethod() {
        std::cout << "This is a public method." << std::endl;
    }
};

int main() {
    PublicExample obj;
    obj.public_var = 10;
    obj.PublicMethod();

    return 0;
}
```

2. `protected` 접근 범위:

```cpp
#include <iostream>

class ProtectedExample {
protected:
    int protected_var;

    void ProtectedMethod() {
        std::cout << "This is a protected method." << std::endl;
    }
};

class DerivedProtected : public ProtectedExample {
public:
    void AccessProtected() {
        protected_var = 20; // 파생 클래스에서 protected 멤버 접근 가능
        ProtectedMethod(); // 파생 클래스에서 protected 메서드 접근 가능
    }
};

int main() {
    DerivedProtected derived;
    derived.AccessProtected();

    return 0;
}
```

3. `private` 접근 범위:

```cpp
#include <iostream>

class PrivateExample {
private:
    int private_var;

    void PrivateMethod() {
        std::cout << "This is a private method." << std::endl;
    }
};

int main() {
    PrivateExample obj;
    // obj.private_var = 30; // 에러: private 멤버는 외부에서 접근 불가능
    // obj.PrivateMethod(); // 에러: private 메서드는 외부에서 접근 불가능

    return 0;
}
```

## 10.7 추상화 데이터형

일반적인 개념을 표현하기 위해 클래스를 정의한다.

예를 들면 클래스를 사용하는 것은 추상화 데이터형(ADT) 이라고 부른다.

> 추상화 데이터형은 내부 구현의 세부사항을 숨기고 일반화된 인터페이스를 제공하는 데이터 타입을 의미합니다.
> 이는 데이터 구조나 연산을 추상화하여 사용자에게 편의성과 보안성을 제공하기 위한 개념입니다.
> 추상화 데이터형은 "추상화"라는 용어처럼 구체적인 구현에 대한 **세부사항을 감추고 필요한 기능과 동작만 노출**합니다.

스택(Stack)은 추상화된 데이터 형태 중 하나로, 데이터를 저장하고 관리하는 자료 구조입니다


* 스택의 주요 연산은 다음과 같습니다

```
push(item): 스택에 데이터를 추가하는 연산입니다. 새로운 데이터가 스택의 맨 위에 위치하게 됩니다.
pop(): 스택에서 맨 위에 있는 데이터를 제거하는 연산입니다. 가장 마지막에 추가된 데이터가 제거됩니다.
top(): 스택의 맨 위에 있는 데이터를 반환하는 연산입니다. 제거하지 않고 데이터를 확인할 때 사용됩니다.
```
# 11 클래스의 활용













