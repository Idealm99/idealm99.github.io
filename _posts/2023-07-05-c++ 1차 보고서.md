---
layout: single
title:  "2023 C++ 1차 보고서"
categories: coding
toc: true
author_profile: false
---

<head>

  <style>
    table.dataframe {
      white-space: normal;
      width: 100%;
      height: 240px;
      display: block;
      overflow: auto;
      font-family: Arial, sans-serif;
      font-size: 0.9rem;
      line-height: 20px;
      text-align: center;
      border: 0px !important;
    }

    table.dataframe th {
      text-align: center;
      font-weight: bold;
      padding: 8px;
    }

    table.dataframe td {
      text-align: center;
      padding: 8px;
    }

    table.dataframe tr:hover {
      background: #b8d1f3; 
    }

    .output_prompt {
      overflow: auto;
      font-size: 0.9rem;
      line-height: 1.45;
      border-radius: 0.3rem;
      -webkit-overflow-scrolling: touch;
      padding: 0.8rem;
      margin-top: 0;
      margin-bottom: 15px;
      font: 1rem Consolas, "Liberation Mono", Menlo, Courier, monospace;
      color: $code-text-color;
      border: solid 1px $border-color;
      border-radius: 0.3rem;
      word-break: normal;
      white-space: pre;
    }

  .dataframe tbody tr th:only-of-type {
      vertical-align: middle;
  }

  .dataframe tbody tr th {
      vertical-align: top;
  }

  .dataframe thead th {
      text-align: center !important;
      position: sticky;
      padding: 8px;
      top = 0;
  }

  .page__content p {
      margin: 0 0 0px !important;
  }

  .page__content p > strong {
    font-size: 0.8rem !important;
  }

  </style>
</head>

# **목차**

[1. c++ 첫걸음](#1)

[2. c++ 시작하기](#2)

[3. 데이터 처리](#3)

[4. 복합 데이터형](#4)

[5. 루프와 관계 표현식](#5)

---

# 1장 c++ 첫걸음<a class="anchor" id="1"></a>

## 1.1 c++ 사용하는 이유

    1.효율적이며,크기가 작고 실행 속도가 빠르며 이식성이 뛰어난 c를 그대로 물려받았다 
    2. 객체지향을 지원한다.
    3. 일반화 프로그래밍 추가

## 1.2 객체 지향 프로그래밍

    구조적 프로그래밍 철학이 프로그램의 간결성, 신뢰성 유지 보수의 용이성에 많은 향상을 가져왔지만 
    규모가 큰 프로그래밍은 여전히 어렵다. 
    이 문제를 해결하기 위해서 객체 지향 프로그래밍 철학이 등장했다. 
    객체지향 프로그래밍은 데이터를 강조한다. 또한 언어 자체를 해결해야 할 문제에 맞춘다.
    즉 해결해야 할 문제의 특성에 맞게 데이터형 자체를 설계하는데
    c++ 에서는 class 가 그와 같은 목적으로 설계되는 새로운 데이터형이다. 
    객체를 정확하게 서술하는 클래스를 먼저 설계 해야한다. 
    저수준의 클래스를 먼저 설계한 후에 고수준의 프로그램 설계를 하는데 이를 상향식 프로그래밍이라고 한다.

## 1.3 일반화 프로그래밍

 일반화 프로그래밍과 oop는 소스코드를 재활용하고 포괄 개념의 추상화 기술을 서로 공유한다. 

## 1.4 프로그래밍 절차

![절차](https://github.com/Idealm99/idealm99.github.io/assets/112872986/2d8f4946-c248-4cc3-80cf-0da3fd0dca77)

## 1.5 소스 코드의 파일 이름 구성 요소

    spiffy.ccp 

    spiffy는 기본 파일 이름 ccp는 확장자이다.

### 1.5.1 소스코드의 확장자 종류

![KakaoTalk_20230705_144418983](https://github.com/Idealm99/idealm99.github.io/assets/112872986/f367c924-83a8-4784-82e6-5ec6eb243a01)

## 1.6 컴파일러

   Unix는 CC 대문자임

# 2장 c++ 시작하기<a class="anchor" id="2"></a>

## 2.1 main() 함수 

     int main()
     {
          구문들
          return 0;
     }
    
기본적으로 이러한 형태를 가지고 있다.
c++에서는 모든 구문이 끝날 때 세미콜론(;)을 붙여야한다.
그리고 main() 함수의 끝에 있는 구문은 return 구문이다. 이것은 함수를 종료하는 역활을 한다.

    int main 이 부분을 함수 이름 (인자리스트, 매개변수 리스트 ) 괄호 안의 이름들이다.

    int main(void) 괄호 안에 void가 있는것은 그 함수가 다른 함수로부터 어떠한 정보도
    전달받지 않는다는 것을 명시적으로 밝히는 것이다.
    // 괄호 안을 비워두는 것은 괄호 안에 void가 있는 것과 같다
    
    주석은 // 를 붙이면 된다 이것은 컴파일러가 읽지 않는다.

## 2.2 c++ 전처리기와 iostream 파일

     #include <iostream>    // 전처리 지시자
     이 지시자는 전처리기에게 iostream 파일의 내용을 프로그램에 추가하라고 지시한다.

그렇다면 왜 iostream 파일의 내용을 프로그램에 추가할까?

     그 이유는 프로그램 바깥 세상이 정보를 주고받을 수 있도록 하기 위해서다.
     count을 사용하려면 이러한 정의가 필요하다
     **cout은 printf와 비슷한 것이다**

## 2.3 이름 공간

다음과 같은 이름 공간 지시자를 사용한다. 그러면 iostream.h 대신에 iostream을 사용할 수 있게 해준다.

     using namespace std;
     
이것을 using 지시자라 한다.
그리고 위에 코드를 작성하면 

    std::cout << " 이렇게 using 지시자를 생략하고 작성할 수 있다.";
    std::cout << std::endl;

## 2.4 cout 을 이용한 출력

cout << (문자열,수,문자); 에서 << 는 (문자열,수,문자)를 cout에 전달한다는 것을 뜻한다.

새로운 행으로 시작하는 방법은
    *조정자 endl은 새로운 행이 시작된다는 코드이다.
    *다른 방법으로는 cout << " 다음 행으로 |n"; |n 이 있다.

### 2.4.1 cout의 새로운 사용법

    int carrots = 25;
    cout << carrots;

위 코드는 crrots라는 단어를 출력하지 않고 변수 carrots에 현재 저장되어 있는 값인 정수 25를 출력한다

    1. cout은 carrots 를 정수 25로 대체한다
    2. 정수 25를 적당한 출력 문자 '2' '5'로 변환한다.
    
이처럼 cout는 문자열뿐만 아니라 정수도 출력할 수 있다. cout은 carrots가 변환할 필요가 있는 정수라는 사실을 알고 있다

    
## 2.5 c++ 소스코드 모양

    #include <iostream>
        int
    main
    () {   using
         namespace
             std;  cout
                 <<
      "이게 가능하다고?"
      ;   cout <<
      endl; erturn 0;}

이렇게 작성하는 것도 가능하다.

    int ma in()       // 이름 안에 빈칸이 있어서 틀리다
    re
    turn 0;           // 키워드 안에 캐리지 리턴이 있어서
    cout << "Behold the Beans
    of Beauty!";      //문자열 안에 캐리지 리턴이 있어서 틀리다

## 2.6 cin을 이용한 입력 

    cin >> carrots; 
    
 이 코드로 cin에 있는 값을 carrots 쪽으로 흐른다는 것을 보여주는 코드다
 
 cin은 키보드로 넣은 일련의 문자들인 입력을 그것을 저장할 변수가 받아들이는 형태로 바꾼다.

## 2.7 cout에 의한 출력의 결합

iostream 파일에는 << 연산자가 여러 개의 출력을 하나로 결합(연결)
있도록 정의되어 있다

    cout << "이제 당근은 모두 " << carrots << "개이다." << endl;

이것은 문자열 출력과 정수 출력을 하나의 구문으로 결함한다. 이것의 실행 결
다음과 같은 세 행의 코드가 만들어 내는 결과와 동일하다.

    cout << "이제 당근은 모두"; 
    cout << carrots;
    cout << "개이다.";
    cout << endl;

또한 독자가 cout 을 사용하리는 권고를 받아들이기로 했다면, 하나로 결합된 .
구문을 다음과 같이 네 행에 결쳐 작성할 수도 있다.

    cout << "이제 당근은 모두"
    << carrots
    << "개이다."
    << endl; 
  

## 2.8 함수

C++에는 함수의 유형이 2가지가 있다.

    1. 리턴값이 있는 것과 리턴값이 없는 것
    2. 표준 함수 라이브러리에 있는 함수를 사용할 수도 있고 사용자가 직접 만들어 사용할 수도 있다.

### 2.8.1 리턴값이 있는 함수

리턴값이 있는 함수는 변수에 대입할 수 있는 하나의 값을 만들어 낸다.

![sqrt](https://github.com/Idealm99/idealm99.github.io/assets/112872986/28e03538-3844-4239-b605-2e04f83d244a)

함수가 잡업을 끝내면 구문에 있는 함수 호출이 그 리턴값으로 대체된다.

즉 매게변수는 함수에 전달되는 정보이고, 리턴값은 함수가 돌려주는 값이다

실수를 c++에서는 double형으로 나타낸다 
```
    double sqrt(double);   //함수원형
    앞의 double은 sqrt() 함수가 double형의 값을 리턴한다는 뜻이고
    뒤의 double은 sqrt() 함수가 double형의 매개변수를 전달받는다는 뜻이다.

    double x;        // x를 double형 변수로 선언한다.
    x = sqrt(6.25);
   ````
 
### 2.8.2 변이 함수들

    double pow (double , double);   //2개의 매개변수를 가진 함수 원형
    int rand(void);                 // 매개변수가 없는 함수 원형
    myGuess = rand();               // 매개변수가 없는 함수 호출
    void bucks(double);             // 리턴값이 없는 함수 원형
    bucks(1.54);                    // 리턴값이 없는 함수 호출

### 2.8.3 사용자 정의 함수

    #include <iostream>
    void simon(int);
    int main() 
    {
        using namespace std;
        simon(3);
        return 0;
    }
    void simon( int n)
    {
       using namespace std;
       cout << "simon 왈 발가락을" << n << "번 두드려라." << endl;
    }

    출력물
    simon 왈 발가락을 3번 두드려라.

이러한 결과물이 된다 simon이라는 함수를 만들고 void simon( int n)에서 () 안에 입력받을 변수 타입을 정해주고
 main에서 함수를 호출하면 이렇게 simon함수 안에 있는 것들이 실행된다.

 만약 simple - simon(3); 이면 void형 함수이므로 이렇게 사용할 수 없다.
 
 ### 2.8.4 리턴값이 있는 사용자 정의 함수

 
# 3장 데이터 처리<a class="anchor" id="3"></a>

## 3.1 변수 이름

    * 변수 이름에는 영문자,숫자,밑줄 문자만을 사용할 수 있다.
    * 숫자를 변수 이름의 첫 문자로 사용할 수 없다.
    * 변수 이름에 대문자와 소문자는 구별된다
    * C++의 키워드는 변수 이름으로 사용할 수 없다
    * 두개의 밑줄 문자로 시작하는 이름이나 밑줄 문자와 대문자로 시작하는 이름은 그것을 사용하는 컴파일러와 리소스가
    하나의 밑줄은 컴파일러와 리소스가 전역 식별자로 사용
    * 변수 이름의 제한이 없으며 변수 이름에 쓰인 모든 문자들이 유효하다.

## 3.2 정수형 

정수는 2, 54 87 같이 소수부가 없는  수를 말한다. 그런데 컴퓨터의 메모리 용향에는 한계가 있으므로 길이가 제한된다.
양수값과 음수값 모두 나타낼 수 있으나 unsigned 데이터형은 양수값만 나타낼 수 있다.
기본 정수형 크기 순서로는

    char < short < int < long < long long 순이다.
    *short 16bit
    *int 32bit
    *long long 64bit more

    선언 방법

    *short score;
    *int score;
    *long score;

### 3.2.1 데이터 크기 알아내는 방법

1. sizeof 연산자 데이터형의 크기를 바이트 단위로 리턴한다
2. climits 헤더 파일 열어 보는 방법

climits에 정의되어 있는 기호 상수들

![climits](https://github.com/Idealm99/idealm99.github.io/assets/112872986/3d32c2af-3fa2-4be2-aba9-c439cab06e9a)

### 3.2.2 초기화 

초기화는 선언과 대입을 하나로 조합한다. 에로
```
    int n_int = INT_MAX;
    int uncle = 5; //uncle 5로 초기화
    int uncle(5);  // C++의 새로운 초기화 문법
```

## 3.3 unsigned 형

C++ 의 unsigned 형은 부호가 없는 정수형입니다. 부호가 없는 정수는 양수만 저장할 수 있습니다. unsigned 형의 범위는 부호가 있는 정수형의 범위보다 큽니다. 예를 들어, unsigned int 의 범위는 0 ~ 4294967295 이고, int 의 범위는 -2147483648 ~ 2147483647 입니다.

unsigned 형을 사용하는 이유는 다음과 같습니다.

* 양수만 저장해야 할 때
* 부호가 있는 정수형보다 더 큰 범위의 정수를 저장해야 할 때
* 부호 오류를 방지해야 할 때

unsigned 형을 사용할 때는 다음과 같은 점에 유의해야 합니다.

* unsigned 형은 부호가 없는 정수형이기 때문에 음수를 저장할 수 없습니다.
* unsigned 형과 부호가 있는 정수형을 연산할 때는 부호가 있는 정수형을 unsigned 형으로 변환합니다.
* unsigned 형과 부호가 있는 정수형의 범위가 다르기 때문에 unsigned 형으로 변환할 때는 주의해야 합니다.

unsigned 만 있는 것은 unsigned int 를 줄여서 나타낸 것이다.

---

## 3.4 C++가 상수의 데이터형을 결정하는 방법

1. 상수의 값을 기준으로 데이터형을 결정합니다.
2. 상수의 이름에 접미어를 붙여 데이터형을 지정할 수 있습니다.
3. 상수의 데이터형을 명시적으로 지정할 수 있습니다.

예를 들어, 상수의 값이 100이면 int형으로 결정됩니다. 상수의 이름에 접미어를 붙여 데이터형을 지정할 수도 있습니다. 예를 들어, `const int a = 100;`은 int형 상수 `a`를 선언합니다. 상수의 데이터형을 명시적으로 지정할 수도 있습니다. 예를 들어, `const int a = 100u;`은 unsigned int형 상수 `a`를 선언합니다.

C++ 의 const 는 변수나 함수를 상수로 선언하는 키워드입니다. const 로 선언된 변수는 그 값을 변경할 수 없으며, const 로 선언된 함수는 그 인자를 변경할 수 없습니다. const 는 C++ 의 오류 방지 기능 중 하나로, 프로그램의 안정성을 높이는 데 도움이 됩니다.

const 를 사용하는 방법은 다음과 같습니다.

* 변수 선언시 const 를 사용합니다.
```
const int a = 10;
```
* 함수 선언시 const 를 사용합니다.
```
void f(const int a) {
  // a 의 값을 변경할 수 없습니다.
}
```

const 를 사용하면 다음과 같은 이점이 있습니다.

* 프로그램의 안정성을 높일 수 있습니다.
* 코드를 이해하기 쉽게 만들 수 있습니다.
* 코드를 유지보수하기 쉽게 만들 수 있습니다.

const 를 사용하면 C++ 로 작성하는 프로그램의 품질을 향상시킬 수 있습니다.

---

### 3.4.1 char 형 문자와 작은 정수

문자와 숫자를 저장하기 위한 형태이다.

char형은 문자들을 처리하는데 사용할 수도 있다.

예를 들어서 ASCII 에서 A는 65다

    char ch= 65;
    cout << ch

    출력물 = A
    

입력할 때 문자 A에 해당하는 코드인 65을 ch에 입력하면 숫자가 아닌 그에 해당하는 문자인 A가 나온다.
이것은 char가 바꾸는 것이 아닌 cout에서 변환하는 것이다.

cout.put(A);은 ASCII로 변환하지 않고 문자 그대로 나오게 한다.
```
    char alarm = '|a';
    cout << alarm << "틀렸습니다!|a|n";
    cout << "정답은|n 김소월의 |"진달래 꽃|"입니다!|n";
```

    *실행 결과*
    정답은
    김소월의 "진달래 꽃"입니다!

![이스케이프](https://github.com/Idealm99/idealm99.github.io/assets/112872986/12d4b318-0e96-4ff9-a916-49945f47a8db)

signed char , unsigned char

int 형과 달리 char 형은 signed 형이나 unsigned형으로 미리 정해져 있지 않다.
그러나 char 형이 어느 특별한 한 가지 행도만을 보여야 한다면 

signed char bar;

unsigned char bar;
로 나타내면 된다.

---

#### 3.4.2 wchar_t, char16_t, char32_t

C++의 wchar_t, char16_t, char32_t는 모두 멀티바이트 문자를 저장하기 위한 데이터 타입입니다. wchar_t는 가장 일반적인 멀티바이트 문자 타입으로, UCS-2 코드 포맷을 사용합니다. char16_t는 UTF-16 코드 포맷을 사용하며, char32_t는 UTF-32 코드 포맷을 사용합니다.

wchar_t는 UCS-2 코드 포맷을 사용하기 때문에, UCS-2 코드 포맷에 해당하는 문자만 저장할 수 있습니다. char16_t는 UTF-16 코드 포맷을 사용하기 때문에, UTF-16 코드 포맷에 해당하는 문자만 저장할 수 있습니다. char32_t는 UTF-32 코드 포맷을 사용하기 때문에, UTF-32 코드 포맷에 해당하는 모든 문자를 저장할 수 있습니다.

wchar_t, char16_t, char32_t는 모두 문자열을 저장하기 위한 데이터 타입이므로, char 타입과 마찬가지로 문자열 연산을 수행할 수 있습니다. 예를 들어, wchar_t, char16_t, char32_t 타입의 문자열을 연결하거나, 문자열의 길이를 구하거나, 문자열을 비교하는 등의 연산을 수행할 수 있습니다.

wchar_t, char16_t, char32_t는 모두 char 타입보다 메모리 공간을 더 많이 차지합니다. 따라서, 문자열의 크기가 크지 않은 경우에는 char 타입을 사용하는 것이 더 효율적일 수 있습니다.

---

### 3.4.3 bool형 

bool형은 true 또는 false 형으로 나오게 하는 데이터형인데 하나의 값만 가질 수 있다.

---

## 3.5 const 제한

기호상수를 다르는 방법이고 const 키워드를 사용하여 변수를 선언하고 초기화하는 것이다.
예를 들어서 1년의 달 수를 기호 상수로 나타내고 싶다면 프로그램에 다음과 같은 행을 넣으면 된다.

    const int MONTHS = 12;

이후 MONTHS에 어떠한 변경을 할려고 해도 가능하지 않고 에러가 뜬다 . 3이라는 수를 4로 바꿀려고 하는 것과 같다.

그리고 선언할 때 초기화해야한다!!

---

## 3.6 부동 소수점수

### 3.6.1 부동 소수점 표

2.52e+8    // E 또는 e를 사용할 수 있으며 +는 생략할 수 있다

8.33F-4    // 지수는 음수일 수도 있다

7E5        // 7.0+05와 같다

-18. 32e13 // 앞에 +나 - 부호를 넣을 수 있다

1.69e12    // 2010년 브라질 공채 (브라질 통화 기준: reais)

5.98E24    // 킬로그램 단위로 지구의 질량

9.11e-31   // 킬로그램 단위로 전자의 질량.

### 3.6.2 부동 소수점형

              float , double  , long double
    최소 비트 : 32      48         80,96,128

### 3.6.3 부동 소수점형 상수

부동 소수점형 상수를 float 형으로 저장하고 싶으면 F,f 점미어로 
long double 형으로 저장하고 싶으면 L,l 점미어로 사용해라

    예
    1.234f
    
    1.234F
    
    1.234L
    
    1.234l l대신에 L을 사용해라

### 3.6.4 부동 소수점의 장단점

1. 정수와 정수 사이에 있는 값을 나타낼 수 있다.
2. 스케일을 사용하여 매우 큰 범위의 값을 나타낼 수 있다.
그러나 부동 소수점수 연산은 수치 연산 보조 프로새서 없는 컴퓨터에서 정수 연산보다 속도가 느리다.

```
    // fltadd.cpp -- float형에서의 정밀도 손실 문제
    #include <iostream>
    int main ()
   {
    using namespace std;
    float a = 2.34+22f;
    float b=a + 1.0f;
    cout << "a = " << a << endl;
    cout << "b - a = " << b - a << endl;
    return 0;
   }

  ``` 

프로 그램은 어떤 수에 1을 더한 후 원래의 수를 뺀다. 예상되는 결과는 1
이어야 한다. 그러나 실제로 그럴까? 다음은 우리가 사용한 시스템에서 
프로그램을 실행한 결과이다.

    a p 2.34e+022
    b - a = 0

이렇게 결과가 나온 이유는 2.34E+22가 소수점 위로 23개의 숫자를 가진 큰 수이기 때문에 발생한 것이다.

이 수에 1을 더하는 것은 23번째 숫자에 1을 더하는 것과 같다 

float형은 처음 6개의 숫자 또는 7개의 숫자까지만 나타낼 수 있으므로 23번째 숫자에 1을 더하는 것은
아무런 효과도 갖지 못한다.

---

## 3.7 C++ 산술 연산자

    +, -, *, /, % 
    + : 두개의 피연산자를 더한다
    - : 두개의 피연산자를 뺀다
    * : 두개의 피 연산자를 곱한다
    / : 두개의 피 연산자를 나눈다
    % : 두개의 피 연산자를 나누고 나머지를 구한다.

### 3.7.1 연산 순서 : 우선순위와 결합 방향

(*,/,%) > +, - 같은 우선순위는 앞에 있는 연산자 먼저

### 3.7.2 나눗셈에 대한 보충

    정수 나s눗셈: 9/5 = 1
    부동 소수점수 나눗셈: 9.0/5.0 = 1.800000
    혼합 나눗셈: 9.0/5 = 1.800000
    double형 상수: 1e7/9.0 = 1111111.111111
    fioat형 상수: 1e7f/9.0f = 1111111.125000

### 3.7.3 데이터형 변환

C++에서 데이터형 변환은 변수나 값의 데이터형을 다른 데이터형으로 변환하는 과정을 의미합니다. 데이터형 변환은 때로는 필요한 연산을 수행하거나 변수를 다른 형식으로 표현해야 할 때 유용합니다. C++에서는 명시적(explicit) 변환과 암시적(implicit) 변환 두 가지 유형의 데이터형 변환을 지원합니다.

암시적 변환(묵시적 변환, Implicit Conversion):
암시적 변환은 컴파일러가 자동으로 수행하는 데이터형 변환이며, 컴파일러가 허용하는 변환 규칙을 따라 수행됩니다. 일반적으로 작은 크기의 데이터형에서 큰 크기의 데이터형으로의 변환이나 정밀도 손실이 없는 변환 등이 암시적으로 처리됩니다. 예를 들어, 정수에서 실수로의 변환, 작은 정수형에서 큰 정수형으로의 변환 등이 암시적 변환이 될 수 있습니다.


    int num1 = 10;
    double num2 = num1;  // 암시적 변환: int를 double로 변환
    
명시적 변환(명시적 형변환, Explicit Conversion):
명시적 변환은 프로그래머가 직접 지정하여 수행하는 데이터형 변환으로, 명시적으로 변환 연산자를 사용해야 합니다. 이러한 변환은 데이터의 손실이 발생하거나 특정 연산을 수행하기 위해 필요한 경우에 사용됩니다. C++에서는 C 스타일의 형변환과 C++ 스타일의 형변환(deprecated) 두 가지 방법으로 명시적 변환이 가능합니다.

C 스타일 형변환:
C 스타일의 형변환은 기존 C 언어에서 사용되던 형식으로, (타입) 형태로 표현됩니다.

    double num1 = 3.14;
    int num2 = (int)num1;  // 명시적 변환: double을 int로 변환
    
C++ 스타일 형변환 (deprecated):
C++에서는 C 스타일 형변환 대신, C++ 스타일의 형변환을 권장합니다. C++ 스타일 형변환은 다음 네 가지 형태로 사용될 수 있습니다.

static_cast<타입>(표현식): 일반적인 형변환에 사용되며, 컴파일 타임에 검사됩니다.
dynamic_cast<타입>(표현식): 클래스 계층 구조에서의 형변환에 사용되며, 실행 중에 타입을 검사합니다.
reinterpret_cast<타입>(표현식): 포인터 타입 사이의 형변환에 사용되며, 주소 값을 바꾸거나 포인터 크기를 변경하는 데 사용됩니다.
const_cast<타입>(표현식): const 한정자를 추가하거나 제거하기 위한 형변환에 사용됩니다.


    double num1 = 3.14;
    int num2 = static_cast<int>(num1);  // 명시적 변환: double을 int로 변환
    
#### 표현 방법

구식은 (int) 1.32
신식    int (1.32)

### 3.7.4 auto 선언

초기화 선언시 테이터형을 쓰지 않고 auto를 사용할 수 있다.

    auto n =100;  //n은 정수
    auto n =100.2;  //n은 double
    auto n =10.3e12L;  //n은 long double

하지만 이것만 쓰는 것은 좋지 않다 왜냐하면.

0.0 대신에 0을 사용하는 경우 문제가 발생할 수 있다. (나중에 9장에서 자세하게 다룹니다.)

# 4장 복합형 데이터<a class="anchor" id="4"></a>

## 4.1 배열

배열은 데이터형이 같은 여러 개의 값을 연속적으로 저장할 수 있는 데이터구조이다.

배열 선언 구문에서 선언하는 3가지

1. 각 원소에 저장될 값의 데이터형
2. 배열의 이름
3. 배열 원소의 개수

배열을 개별적인 접근을 위해 인덱스( subscript, index)를 사용하여 배열 원소에 차레로 번호가 매겨진다.
배열 인데스는 항상 0부터 시작한다.

### 배열 초기화 규칙

1. 배열의 초기화는 배열을 정의한 곳에서만 사용할 수 있다.
2. 배열을 부분적으로 초기화하면 컴파일러가 나머지 원소들을 모두 0으로 설정한다(첫 번째 원소만 0으로 초기화하면 나머짇 0이된다)
3. ([]) 대괄호 안을 비워두면 초기화 값의 개수를 헤아려 배열 원소의 개수를 결정한다. ex) int a[]={1, 2};

### C++11 배열 초기화

c++11에서 몇 가지가 추가 되었다.

1. 배열을 초기화할 떄 = 부호를 사용하지 않아도 된다.
2. 중괄호 공백하여 모든 배열을 0으로 초기화할 수 있다.
3. 리스트 초기화시에 narrowing 을 방지할 수 있다.

## 4.2 문자열

문자열이란 메모리에 바이트 단위로 연속적으로 저장되어 있는 문자들을 말한다.

c++에서 두가지 방법으로 문자열을 처리한다.

1. C로부터 유래한 C스타일의 문자열 처리 방법

모든 문자열의 마지막 문자가 반드시 *널* 문자여야한다. 널 문자는 |0 러 쓰며 ASCII코드가 0인 문자이다 그것은 문자열의 끝에 표시한다.

예를 들어서

    char dog[3]= {'a', 'b' , 'c' };       // 문자열이 아니다
    char dog[3]= {'a', 'b' , 'c','|0' };  // 문자열이다.

그러나 이보다 좋은 방법이 있다

    char cat[10] = "Mr. Cheeps";    // |0을 저장한다.
    char cat[] = "Mr. Cheeps";      // 컴파일러가 알아서 처리한다.
    (") 로 묶인 문자열은 끝내기 널 문자를 암시적으로 가지고 있다.

char size = 'S'; 맞다

char size = "S" 데이터형 불일치

왜냐하면 "S"는 두개의 문자 S 와 |0 로 구성된 문자열을 나타낸다.

### 문자열 상수의 결합

문자열이 너무 길면 

    cout << "I love" "you"
    cout << "I love you"
    cout << "I lo" "ve you"
    모두 같게 출력된다.

### 배열에 문자열 허용

1. 배열을 문자열 상수로 초기화하는 방법
2. 키보드 입력이나 파일 입력을 배열에 저장하는 방법

    1. char name1[10] = "C++owboy";
    2. char name2[10];
       cin >> name2
    문자열에 칸에서 입력되지 않은 곳은 |0으로 채워진다 예로 C + + o w b o y |0 |0 이런 식로

### 한 번에 한 행의 문자열 입력 읽기

#### getline()

getline()함수는 엔터키에 의해 전달되는 개행 문자를 입력의 끝으로 간주하여 한 행 전체를 읽는다
cin.getline()함수 호츨로 사용함으로써 이 메서드를 호출할 수 있다.


cin.getline( 배열 이름, 문자들의 한계) 
한계가 20이면 19개까지 문자들을 입력받을 수 있다 나머지 한 자리는 널 문자를 위해 예비해 두는 것이다.

     ex)cin.getline( name, 20 );    //이 구문은 한 행 전체를 읽어 name 배열에 저장한다.
     이때 그 행의 문자들의 개수는 최대 19개이다.

#### get() 을 이용한 행 단위 입력

개행 문자를 읽어서 버리지 않고 입력 큐에 그대로 남겨둔다.

    cin.get(name, size);
    cin.get(name2, size);   //문제 발생
    * 첫 번째 호출이 입력 큐에 개행 문자를 그대로 남겨 두기 대문에 두 번째 호출은 
    그 개행 문자를 첫 문자로 만나게 된다.
    그래서  get()은 읽을 것도 없이 곧 바로 행에 끝에 도달했다고 결론을 내린다.

다행히 get()의 한 변종으로부터 도움을 받을 수 있다

    cin.get(name, size);    // 첫 번째 행을 읽는다.
    cin.get();              // 개행 문자를 읽는다.
    cin.get(name2, size);   // 두 번째 행을 읽는다.
    
cin.get();을 사용하면 개행 문자를 읽어서 처리하고 다음 행의 입력으로 넘어가게 할 수 있다.

또 다른 방법은 두 개의 클래스 맴버 함수를 결합하여 사용하는 것이다.

    cin.get(name, size).get();   // 맴버 함수들을 결합한다

    cin.getline(name1, size).cin.getline(name2, size);    // 맴버 함수들을 결합한다.
    (cin.getline()을 두번 호출하는 것과 같다) 
    
getline 대신에 get을 사용하는 이유
1. 구식 c++ 에는 getline이 없기 때문에
2. get 이 사용자를 다소 신중하게 만들기 때문에
   예를 들어서 배열에 한 행을 저장하기 위해 get을 사용하면 get이 배열의 수납 범위를 벗어나지 않는
   전체 행을 읽어들였는지 어떻게 알까 그 다음 입력 문자를 살펴보면 된다.
   즉 *getline은 사용하기 좀 더 편하고 get은 에러 체킹이 좀 더 쉽다*

### 문자열과 수치의 혼합 입력

```
#include <iostream>

using namespace std;

int main()
{
    cout<<"원룸 언제부터 살았어?\n";
    int year;
    std::cin >> year;
    cout << "사는 도시는 어디야? \n";
    char address[80];
    cin.getline(address, 80);
    cout << "입주년도" << year << endl;
    cout << "도시는" << address << endl;
    cout << "등록 끝 \n";


    return 0;
}
```
출력물

    원룸 언제부터 살았어?
    2022
    사는 도시는 어디야? 
    입주년도2022
    도시는
    등록 끝 

```
#include <iostream>

using namespace std;

int main()
{
    cout<<"원룸 언제부터 살았어?\n";
    int year;
    (std::cin >> year).get();
    cout << "사는 도시는 어디야? \n";
    char address[80];
    cin.getline(address, 80);
    cout << "입주년도" << year << endl;
    cout << "도시는" << address << endl;
    cout << "등록 끝 \n";


    return 0;
}
```
출력물

    원룸 언제부터 살았어?
    2022
    사는 도시는 어디야? 
    안성
    입주년도2022
    도시는안성
    등록 끝 


위에 코드에서 보이듯이 std::cin >> year; 이 코드를 입력할 기회를 주지 않는다

cin이 입주 연도를 읽어들이고 Enter 키가 만들어 내는 개행 문자를 입력 큐에 남겨 두기 때문에
발생하는 문제이다.

cin.getline()은 입력 큐에 남겨진 개행 문자를 빈 행으로 읽어들이고 address 배열에

널 문자열을 대입한다. 이 문제를 해결하는 방법은 주소를 읽기 전에 개행 문자를 읽어

허공에다 버리는 것이다. 그래서 아래 코드에서 처럼 get()을 사용하여 문제를 해결할 수 있다.

* C++프로그램은 문자열을 처리하기 위해 배열 대신에 포인터를 더 많이 사용한다

## 4.3  String 클래스

문자열을 저장하는 데 문자 배영을 사용하는 대신에 string형 변수(객체)를 사용할 수 있다.

string 클래스를 사용하려면 프로그램에 string 헤더 파일을 포함시켜야 한다.

    #include <string>    // string 클래스 사용하기 위해

string 클래스는 std 이름 공간에 속해 있으므로 using 지시자를 사용하거나 std::string를
사용하여 그 클래스를 참조해 주어야 한다.

```
#include <iostream>
#include <string>               // string 클래스를 사용한다
int main()
{
    using namespace std;
    char charr1[20];            // create an empty array
    char charr2[20] = "jaguar"; // create an initialized array
    string str1;                // create an empty string object
    string str2 = "panther";    // create an initialized string

    cout << "Enter a kind of feline: ";
    cin >> charr1;
    cout << "Enter another kind of feline: ";
    cin >> str1;                // use cin for input
    cout << "Here are some felines:\n";
    cout << charr1 << " " << charr2 << " "
         << str1 << " " << str2 // use cout for output
         << endl;
    cout << "The third letter in " << charr2 << " is "
         << charr2[2] << endl;
    cout << "The third letter in " << str2 << " is "
         << str2[2] << endl;    // use array notation
    // cin.get();
	// cin.get();

    return 0; 
}

```     
실행 결과물 

    Enter a kind of feline: ocelot
    Enter another kind of feline: tiger
    Here are some felines:
    ocelot jaguar tiger panther
    The third letter in jaguar is g
    third letter in panther is n

-위 코드를 통해서 배울 내용-

* C스타일 문자열로 string 객체를 초기화할 수 있다.
* cin을 사용하여 string 객체에 키보드 입력을 저장할 수 있다
* cout을 사용하여 string 객체에 키보드 입력을 저장할 수 있다.
* 배열 표기를 사용하여 string 객체에 저장되어 있는 개별적인 문자들에 접근할 수 있다.

*string 객체와 문자 배열의 가장 큰 차이점은 string 객체를 배열이 아니라 단순한 변수로 선언하는 것이다.*

### C++ 문자열 초기화

    char first [] = {"이건 좀 불편한데"};
    string second = {" 그래 이거지 이거야"};

### 대입, 결합, 추가

string 클래스는 배열보다 조작이 간단하다.
하나의 배열을 다른 배열에 간단하게 대입할 수 없지만 하나의 string 객체를 다른 string 객체에 
간단하게 대입할 수 있다.

```
char chaarr1[20];    // 빈 배열을 생성한다
char chaarr2[20] = "이렇게";// 초기화된 배열을 생성한다
string str1;                //빈 스트링 객체를 생성한다
string str="이렇게";         //초기화된 스트링 객체를 생성한다
charr1 = charr2;    //틀리다 배열 대입 X
srt1 = str2;        //맞다 객체 대입 O
```

```
str3= str1 + str2;
//위 코드와
strcpy(charr3 , charr1);
strcpy(charr3 , charr2);
// 위에 코드들은 같은 의미를 갖는데 char 배열을 쓰냐 string객체를 사용하냐에 따라 표현 방법이 다르다.

char chaarr2[5] = "이렇게"
strcpy(charr2 ,"이것을 추가한다"); // 메모리 문제 발생

// 길이를 구하는 코드는
int len1 = str1.size();    // str1 의 길이를구한다
int len2 = strlen(charr1); //charr의 길이를 구한다.
```
### string 클래스의 입출력
```
// strtype4.cpp -- line input
#include <iostream>
#include <string>               // make string class available
#include <cstring>              // C-style string library
int main()
{
    using namespace std;
    char charr[20]; 
    string str;

    cout << "Length of string in charr before input: " 
         << strlen(charr) << endl;
    cout << "Length of string in str before input: "
         << str.size() << endl;
    cout << "Enter a line of text:\n";
    cin.getline(charr, 20);     // indicate maximum length
    cout << "You entered: " << charr << endl;
    cout << "Enter another line of text:\n";
    getline(cin, str);          // cin now an argument; no length specifier
    cout << "You entered: " << str << endl;
    cout << "Length of string in charr after input: " 
         << strlen(charr) << endl;
    cout << "Length of string in str after input: "
         << str.size() << endl;
    // cin.get();

    return 0; 
}
```
출력물

    Length of string in charr before input: 0
    Length of string in str before input: 0
    Enter a line of text:
    abcde
    You entered: abcde
    Enter another line of text:
    abcdef
    You entered: abcdef
    Length of string in charr after input: 6
    Length of string in str after input: 6

1. 초기화되지 않은 배열의 내용은 저의되지 않는다
2. strlen() 함수는 배열의 첫 번째 원소에서 출발하여 널 문자에 도달할 때가지 바이트들을 카운트한다.

여기에서 책과 내용이 다른 점은 Length of string in charr before input: 0 이 부분이다

책에서는 2번의 내용으로 27이 나오지만 코드를 돌려본 결과 0으로 나온다.

```
cin >> str; // 한 단어를 읽어 str에 넣는다
cin >> x ;  // 한 값을 읽어 기본 데이터형에 넣는다
```

---

## 4.4 구조체

하나의 배열에 절반은 int형 절반은 char 형으로 만들 수 없다

이 문제를 해결하기 위해서 나온 것이 *구조체*이다.

그리고 구조체는 사용자가 정의할 수 있는 데이터 형이다.

구조체는 2 단계를 거쳐 생성된다.
1. 구조체 서술을 정의하는 단계
   -구조체 안에 저장할 여러 가지 데이터형들을 서술하고 이름을 정한다
2. 구조체 서술에 따라 구조체 데이터 객체를 생성
   
```
struct A  //구조체 선언
{
char name[20];
float volume;
double price;
};
```
여기서 struct는 이 코드가 구조체 서술을 정의하고 있다는 것을 나타낸다.

태그라고도 부르는 식별자 A는  새로 만들어지는 데이터형의 이름으로 사용된다.

이 리스트에는 배열이나 다른 구조체를 포함한 어떠한 종류의 데이터형도 넣을 수 있다.

그리고 마지막에 {} 괄호를 닫을 때 세미콜론(;) 을 붙여야한다.

---

### 4.4.1 프로그램에 구조체 사용하기

예시 코드

```
// structur.cpp -- a simple structure
#include <iostream>
struct a   // structure declaration
{
    char name[20];
    float volume;
    double price;
};

int main()
{
    using namespace std;
    a guest =
    {
        "Glorious Gloria",  // name value
        1.88,               // volume value
        29.99               // price value
    };  // guest is a structure variable of type inflatable
// It's initialized to the indicated values
    a pal =
    {
        "Audacious Arthur",
        3.12,
        32.99
    };  // pal is a second variable of type inflatable
// NOTE: some implementations require using
// static inflatable guest =

    cout << "Expand your guest list with " << guest.name;
    cout << " and " << pal.name << "!\n";
// pal.name is the name member of the pal variable
    cout << "You can have both for $";
    cout << guest.price + pal.price << "!\n";
    // cin.get();
    return 0; 
}
```
구조체 선언 위치는 두가지가 있다 
1. main() 함수의 안에 중괄호
2. main() 함수 밖에 선언을 두는 것을 외부 선언이라 한다
   여러 개의 함수로 이루어지는 프로그램에서는 이것이 커다란 차이가 날 수 있다.
   외부 선언은 선언 이후에 나오는 모든 함수들이 사용할 수 있으나 내부 선언은 그 선언이
   내부에서만 사용할 수 있다. 그래서 외부 구조체 선언을 장려한다.

```
    a guest =         // = 는 생략할 수 있음
    {
        "Glorious Gloria",  // name value
        1.88,               // volume value
        29.99               // price value
    }; 
```

geust.name[0]= G 이다 하지만 배열이 아니라 구조체이기 때문에 geust[0]은 아무 의미가 없다.

---

### 4.4.2 C++11의 구조체 초기화
```
a guest { }; 
```
결국 narrowung은 허용되지 않는다.

---

### 4.4.3 구조체가 string 클래스 맴버를 사용할 수 있을까?

C++에서 구조체가 string 클래스 멤버를 사용할 수 있습니다. 예를 들어 다음과 같이 구조체에 string 클래스 멤버를 추가할 수 있습니다.

```
struct MyStruct {
  std::string name;
};
```

이제 MyStruct 구조체 인스턴스를 생성하고 string 클래스 멤버에 문자열을 할당할 수 있습니다. 예를 들어 다음과 같습니다.

```
MyStruct my_struct;
my_struct.name = "John Doe";
```

마지막으로 MyStruct 구조체의 string 클래스 멤버에 저장된 문자열을 출력할 수 있습니다. 예를 들어 다음과 같습니다.

```
std::cout << my_struct.name;
```

이 코드는 다음과 같은 출력을 생성합니다.

```
John Doe
```
---

### 4.4.4 구조체의 기타 특성

```
#include <iostream>
struct inflatable
{
    char name[20];
    float volume;
    double price;
};
int main()
{
    using namespace std;
    inflatable bouquet =
    {
        "sunflowers",
        0.20,
        12.49
    };
    inflatable choice;
    cout << "bouquet: " << bouquet.name << " for $";
    cout << bouquet.price << endl;

    choice = bouquet;  // 한 구조체를 다른 구조체에 대입
    cout << "choice: " << choice.name << " for $";
    cout << choice.price << endl;
    // cin.get();
    return 0; 
}
```
위에 코드에서 있는 것 처럼 bouquet 구조체의 맴버 값들이 choice 구조체의 맴버들에 각각 대입되었다.

```
struct inflatable
{
    char name[20];
    float volume;
    double price;
}choice,bouquet; //이렇게 바로 2개의 변수를 만들 수 있다. 
```
변수를 생성할 때 초기화를 할 수 있지만 이해하기 어려우니 잘 사용하지 않는다.

---

### 4.4.5 구조체의 배열

```
a gift[100];       // a형 구조체 100개의 배열
cin >> gift[0].volume;  // 첫 번째 구조체의 volume 맴버에 입력
cout << gift[99].volume; << endl; //마지막 구조체의 volume 맴버를 출력
```

gifr 자체는 구조체가 아니라 배열이므로 gifr.volume과 같은 표현은 구조체의 배열을 초기화하는 방법은 
구조체 초기화 규칙과 배열 초기화 규칙을 하나로 결합하는 것이다 

즉 배열 원소가 구조체이므로 배열 원소의 각 값을 구조체 초기화 형식으로 나타낸다

```
a gift[2] =              // 구조체의 배열을 초기화
{
{"bam", 0.5, 21.99},     // 첫 번째 배열 원소인 구조체
{"nom", 0.3, 21.9}       // 두 번째 배열 원소인 구조체
};
```
---

### 4.4.6 구조체 안의 비트 필드

필드형은 정수형이나 열거자여야한다.

```
struct torgle_register{
unsigned int sn : 4; // sn 값 4비트
unsigned int  : 4;   // t사용하지 않음 4비트
bool goodIn : 1;     // 유효한 입력 1비트
bool goodTrogle : 1; // 토글에 성공 1비트
};

```
---

## 4.5 공용체

공용체는 서로 다른 데이터형을 한 번에 한 가지만 보관할 수 있는 데이터 형식이다.

즉 구조체는 모든 데이터 형 vs 공용체는 한 데이터 형만

구문은 구조체와 같지만 의미가 조금 다르다.

```
union one
{
 int int_val;
 long long_val;
 double double_val;
};

```
one 변수는 int 형이나 double 형을 보관할 수 있지만  어느 한 시점에 어느 한 가지만 보관할 수 있다.

```
oe pail;
pail.int_val = 15;    //int 형을 저장
cout << pail.int_val;
pail.double_val = 1.38;  //double 형을 저장 int형 값은 소실
cout << pail.double_val;

```

가장 큰 멤버를 보관할 수 있을 만큼의 공간이 필요하다 

따라서 공용체의 크기는 가장 큰 멤버의 크기이다.

여러 가지 데이터형을 사용할 수는 있지만 이들을 동시에 사용할 수 없을 때 공용체를 사용하면 메모리를 절약할 수 있다.

---

## 4.6 열거체

enum(열거체) 기능은 const 를 사용하여 기호 상수를 만드는 것에 대한 또 다른 방편을 제공한다.

enum을 사용하는 구문은 구조체 구문과 비슷하다 예를 들어

```
enum spectrum ( a, b, c, d, e, f, g};

```

이 구문은 두 가지 일을 수행한다

1. spectrum 을 새로운 데이터형의 이름으로 만든다. (열거체체)
2. a, b, c ... 등을 0에서 7까지의 정수 값을 각각 나타내는 기호 상수로 만든다.  이 상수들을 *열거자라* 부른다

첫 번째 열거자는 0 두번째는 1 

```
spectrum band;    // band는 spectrum형의 변수
band = b;         // 맞다 b 는 열거자다
band= 200;        // 틀리다 2000은 열거자가 아니다
band = c + d;     // 틀리다
int color = c;    // 맞다 spectrum 형이 int 형으로 승급된다.
band = 3;         // 틸리다 int 형이 spectrum형으로 변환되지 않는다.
color = 3 + d;    // 맞다 d가 int 형으로 변환된다.
band = spectrum(3);// 3을 spectrum형으로 데이터형 변환
band = spectrum(300003);// 미확정
```
열거자들에 대해 + 연산자는 정의되어 있지 않다

---

### 4.6.1 열거자 값의 설정

대입 연산자를 사용하여 열거자의 값을 명시적으로 지정할 수 있다.
```
enum bit {a= 1, b =2, c = 3, d = 4};   //대입되는 값들은 정수여야한다. long 형도 가능
enum bit {a= 1, b , c , d = 4};        //일부 열거자에만 명시적으로 값을 대입할 수 있다
```
---

### 4.6.2 열거체의 값 범위

```
enum Day {
  Sunday=2,
  Monday=4,
  Tuesday=8,
};
Day today;
today = Day(6); //맞다 6이 Day 범위 안에 들어왔다 
```
상한 = (열거자 값 중 최대값)< (2^2 or 4^2 중에 큰 값 )-1

---

## 4.7 포인터와 메모리 해제

포인터는 값 자체가아니라 값의 주소를 저장하는 변수이다.

주소 연산자(&) 를 변수 앞에 붙이면 그 벼수의 주소를 알 수 있다. 주소는 16진수로 나타낸다.

포인터라는 특별한 데이터형의 변수에 어떤 주소를 저장한다 
- 즉 포인터의 이름이 주소를 나타낸다.

간접값 연산자 또는 간접 참조 연산자라고 부르는 *를 포인터 이름 앞에 붙이면
그 주소애 저장되어 있는 값이 된다.

예를 들어서

    *a

1. *a는 그 주소에 저장되어 있는 값을 나타낸다.
2. *a 는 보통의 int형 변수와 동등하게 취급된다.

```
int A = 6;
int *B ;

B=&A;
```
결과는

    A = 6 *B = 6
    &A =0012FF7C B = 0012FF7C
    *B = *B+1
    *B = 7 

---

### 4.7.1 포인터의 선언과 초기화

char 과 double 은 바이트 수가 다르고 저장 형식이 다르다 그로므로 포인터를 선언할 때에는 그 포인터가 지시하는 데이터형이 무엇인지 서술해야한다.

예를 들면 

    int * P_u;
    
-* P_u는 int형이라는 것을 나타낸다. P_u는 포인터임에 틀림없다
  
즉 P_u 의 데이터형은 int형을 지시하는 포인터 간단히 *int 형이다.

다시 말해서 P_u는 포인터(주소)이고 * P_u는 포인터가 아니라 int형 변수이다.

C++프로그래머들은 int* P_u; 과 같은 형시으로 사용한다.

    int* P1 , P2;

P1 은 포인터이고 P2는 int형 현수로 생성한다
둘 다 포인터로 만들고 싶으면 각각 * 를 붙여야한다.

tax ptr는 double형을 지시하는 포인
터(혹은 double *형)이고, str는 char형을 지시하는 포인터(char *형)이디
이들은 둘 다 포인터이지만 서로 다른 데이터형을 지시한다. 배열과 마찬가지로, 포
인터도 다른 데이터형을 기초로 하여 만들어진다.

tax _ ptr와 st.
변수 자체의 크기는 같다.  

char형의 주소와 double형의 주소
는 크기가 같다. 그러므로 특정 주소의 크기나 값만 가지고는 그 주소에 저장되
있는 변수의 크기나 총류를 알 수가 없다. 일반적으로 컴퓨터 시스템에 따라서 2비
이트나 4바이트로 주소를 나타낸다

선언 구문을 사용하여 포인터를 초기화할 수 있다. 이러한 경우에, 포인터에 의해
지시되는 값이 아니라 포인터가 초기화된다. 즉, 다음과 같은 구문은

    int higgens e 5;
    int * pt = &higgens;
    
포인터에 의해 지시되는 값인 *pt가 초기화되는 것이 아니라, 포인터인 pt가
higgens 값으로 초기화된다.

---

### 4.7.2 포인터의 위험

포인터는 매우 조심스럽게 사용해야 한다. 포인터를 생성하면 컴퓨터는 주소를 저장하기 위한 메모리를 대입한다.

이것은 그 포인터가 지시하는 데이터를 저장하기 위한 메모리를 대입하는 것이 아니다.

```
long * fellow;
*fellow = 234;
```

여기서 fellow는 포인터이다 그런데 이 포인터가 어디를 지시하고 있는지 알 수 없다. 

왜냐하면 fellow에 주소를대입하는 단계를 빠뜨렸기 때문이다 그렇다면 234는 어디에 저장되어 있는가?

아무도 모른다.


### 4.7.3 포인터와 수

포인터는 개념적으로 정수형과는 다른 데이터형이다. 포인터는 위치를 나타내는 것이다.

따라서  두 개의 위치를 서로 곱한다는 것은 아무런 의미가 없다.

포인터에 정수를 대입할 수 없다.

```
int * pt;
pt = 0XB800000;     // 데이터형 불일치
```
어떤 수를 주소로 사용하려면 데이터형 변환자를 사용하여 적당한 주소형으로 반드시 변환해 주어야 한다.

```
int * pt;
pt = (int *) 0XB800000;  // 데이터형 일치
```
위 코드는 좌변 우변 모두 정수의 주소를 나타낸다.

int형 값을 가지고 있다고 해서 pt를 int형이라고 생각하면 안 된다 

---

### 4.7.4 new를 사용한 메모리 대입☆

C++에서 <font color="yellow"><b> 프로그램을 실행하는 동안에 이름이 없는 메모리를 대입하는 것이 포인터의 진정한 가치이다 </b></font>

이 경우에는 포인터가 그 메모리에 접근할 수 있는 유일한 통로이다. 이러한 것들을 하기 위해서 C++에서는 new 연산자를 사용한다.

프로그램이 실행하는 동안에 int 형 값을 이름 없는 메모리를 대입하고 포인터를 사용하여 
그 메모리에 접근하는 방법

여기서 new 연산자는 중요한 역활을 한다.

1. 어떤 데이터형의 메모리를 원하는지 new 연산자에게 알려주면,
2. new 연산자는 그에 알맞은 크기의 메모리 블록을 찾아내고,
3. 그 블록의 주소를 리턴한다.
4. 이주소를 포인터에 대입하면 된다.

예시로
```
int * pn = new int;
```
1. new int 부분은 int형 데이터를 저장할 새로운 메모리가 필요하다고 프로그램에게 알린다.
2. new 연산자는 뒤따르는 데이터형을 보고 몇 바이트가 필요한지 파악한다
3. 적당한 메모리를 찾아 필요한 만큼 블록을 대입하고
4. 그 주소를 리턴한다
5. 리턴된 주소는 int형을 지시하는 포인터로 선언되어 있는 pn에 대입된다.
   -여기서 pn은 주소이고 *pn은 그 조소에 저장되는 값이다. 

포인터에 변수의 주소를 대입하는 방식과 비교해보면
```
int huggens;
int * pt = &huggens;
```
두 방식 모두 int형의 주소가 포인터에 대입된다.

차이점은 
    두 번째 방식에는 pt를 통하지 않고 huggens를 통하여 int형 값에 접근할 수 있다.
    그러나 
    첫 번째 방식에는 포인터 pn이 int형 값에 접근할 수 있는 유일한 통로이다.

* 여기서 의문전 한 가지
* 
pn이 지시하는 메모리는 이름이 없는데 어떻게 이 메모리에 접근할 수 있는가?

  pn이 데이터 객체를 지시하고 있다고 말한다.
  이때의 객체는 단순히 어떤 대상을 의미한다.
  pn이 지시하는 메모리 블록은 변수가 아니다.

---

### 4.7.5 delete를 사용한 메모리 해제☆

필요할 때 new를 사용하여 메모리를 대입하는 것은 C++의 강력한 메모리 관리 기능의 절반에 불과하다.

나머지 절반은 사용한 메모리를 다시 메모리 풀로 환수하는 delete 연산자다
이것은 메모리를 가장 효율적으로 사용하기 위한 중요한 절차이다.

```
int * ps = new int;    //new로 메모리 대입
...                    // 메모리 사용
delete ps;             // delete로 메모리 해제
```
이렇게 하면 ps가 지시하는 메모리가 해제된다. 그러나 ps 자체가 없어지는 것은 아니다

ps는 새로 대입한 메모리를 지시하는 데 다시 사용할 수 있다.

new를 사용한 후에는 <font color="yellow"><b>반드시 나중에 delete를 사용해야 한다.</b></font>

그렇게 하지 않으면 대입은 되었지만 더 이상 사용이 되지 않는 *메모리 누수가* 발생할 수 있다.

delete를 사용할 때 가장 중요한 요구 사항은, new로 대입한 메모리에만 그것을 사용하는 것이다
- 이것은 new가 사용하는 것과 동일한 주소에 사용해야 한다는 뜻이다

### 4.7.6 new를 사용한 동적 배열의 생성

프로그램이 단지 하나의 값마을 요구한다면 단순한 변수를 선언하는 것이 new와 포인터를 사용하여 작은 데이터 객체를 관리하는 것보다 간단하다.

그러나 배열, 문자열, 구조체 같은 커다란 데이터를 다룰 때에는 new를 사용하는 것이 훨씬 더 효율적이다.

    정적 바인딩 vs 동적 바인딩

    정적 바인딩 : 선언에 의해 배열을 생성하면 프로그램이 컴파일될 때 배열을 위한 메모리가 대입된다.
    프로그램이  실행될 때 이 배열은 사용이 되든 안 되든 항상 메모리를 차지한다. 

    동적 바인딩 : new를 사용하면 배열을 실행 시간에 생성할 수 있고 필요 없으면 생성하지 않을 수도 있다.
    또는 프로그램을 실행하는 동안에 배열의 크기를 결정할 수 있다.
    
    동적 배열 : 이것은 배열이 실행 시간에 생성된다는 것을 뜻한다
    이러한 배열을 

* 동적 배열에 관한 두 가지 기본 사항

  1. new 연산자를 사용하여 동적 배열을 생성하는 방법
  2. 포인터를 사용하여 동적 배열의 원소에 접근하는 방버

---

1. new를 사용한 동적 배열의 생성

배열 원소의 데이터형과 개수를 new에 알져 주면 된다 예를 들어서 

10개의 int형 원소ㅡㄹ 갖는 배열이 필요하다면 대관호 안에 원소의 개수를 넣어 다음과 같은 형식으로 동적 배열을 생성한다.

```
int * psome = new int [10];   // 10개의 int형 값을 저장할 블록을 대입
```

new 연산자는 그 블록의 *첫 번째* 원소의 주소를 리턴한다.
-(new를 사용했으니 반드시 delete 해줘야한다)

```
delete [] psome;     // ㅗㄷㅇ적 배열을 해제
```

배열 전체가 해제된다. 

대괄호는 중간에 위치한다.

즉 new와 delete를 사용할 때 같은 규칙을 지켜야한다.

-new로 대입하지 않은 메모리는 delete로 해제하지 않는다
-같은 메모리 블록을 연달아 두 번 delete로 해제하지 않는다
-new []로 메모리를 대입한 경우에는 delete []로 해제한다
-new를 대괄호 없이 사용했으면 delete도 대괄호 없이 사용한다
-널 포인터에는 delete를 사용하는 것이 안전하다(아무 일도 일어나지 않는다.)

---

2. 동적 배열의 사용

```
int * posem = new int [10];  //10개의 int형 값을 위한 블록을 대입
```

앞의 new 구문은 그 블록에 있는 각각의 원소들을 인식하는 데 필요한 모든 정보를 제공한다

이원소들 중의 어느 하나에 접근하려면 어떻게 해야하는가

    1. 원소에 접근하는 것은 어렵지 않다 
      psome 이 배열의 첫번째 원소를 지시하는 포인터이기 때문에 *psome은 첫 번째 원소의 값이 된다
      첫 번째 원소를 *psome 대신에 psome[0]으로 나타낼 수 있다

    2. 원소는 psome[1]로 나타낼 수 있다.
      나머지 원소들도 모두 이런 방식으로 나타낼 수 있다.

```
#include <iostream>
int main()
{
    using namespace std;
    double * p3 = new double [3]; // space for 3 doubles
    p3[0] = 0.2;                  // treat p3 like an array name
    p3[1] = 0.5;
    p3[2] = 0.8;
    cout << "p3[1] is " << p3[1] << ".\n";
    p3 = p3 + 1;                  // increment the pointer
    cout << "Now p3[0] is " << p3[0] << " and ";
    cout << "p3[1] is " << p3[1] << ".\n";
    p3 = p3 - 1;                  // point back to beginning
    delete [] p3;                 // free the memory
    // cin.get();
    return 0; 
}
```
결과물 

    p3[1] is 0.5.
    Now p3[0] is 0.5 and p3[1] is 0.8.

    p3 = p3 + 1;   //p3이 포인터면 맞고 배열 이름이면 틀리다

배열 이름의 값은 변경할 수 없지만 포인터는 변수이기 때문에 값을 변경할 수 있다.


<font color="blue"><b>연속적으로 지정되어 있는 int형 갑들의 실제 주소는 대개 2바이나 4바이트씩 차이가 난다. p3에 1을 더하면 
실제로는 그 다음 차례 원소의 주소를 지시하게 된다. 포인터 연산에서 이것은 매우 중요하다.</b></font>

## 4.8 포인터, 배열, 포인터 연산

포인터와 배열 이름의 동둥성은 C++가 내부적으로 배열을 처리하는 방법과, 포인
터 연산으로부터 온다. 면저 포인터 연산에 대해 알아보자. 정수형 변수에 1을 더하
면 값이 1만큼 증가한다. 그러나 포인터 변수에 1을 더하면 값이 그 포인터가 지시
하는 데이터형의 바이트 수만큼 증가한다. 예를 들어, double형이 8바이트인 시스
템에서, double형을 지시하는 포인터에 1을 더하는 것은 그 포인터의 수치 값에 8
을 더하는 것과 같다. 또한 short형이 2바이트인 시스템에서, short형을 지시하
는 포인터에 1을 더하는 것은 그 포인터의 값에 2를 더하는 것과 같다.


아래 코드가 이것을 보여 준다. 그리고 이 코드는 C++가 배열 이름을 주소로 해석한다는 중
요한 사실을 보여 준다.


```
// addpntrs.cpp -- pointer ejttpa
#include <iostream>
int main()
{
    using namespace std;
    double wages[3] = {10000.0, 20000.0, 30000.0};
    short stacks[3] = {3, 2, 1};

// Here are two ways to get the address of an array
    double * pw = wages;     // 배열 이름 = 주소
    short * ps = &stacks[0]; // 배열 원소에 주소 연산자 사용
// with array element
    cout << "pw = " << pw << ", *pw = " << *pw << endl;
    pw = pw + 1;
    cout << "pw 포인터에 1을 더함:\n";
    cout << "pw = " << pw << ", *pw = " << *pw << "\n\n";

    cout << "ps = " << ps << ", *ps = " << *ps << endl;
    ps = ps + 1;
    cout << "ps 포인터에 1을 더함:\n";
    cout << "ps = " << ps << ", *ps = " << *ps << "\n\n";

    cout << "배열 표기로 두 원소에 접근\n";
    cout << "stacks[0] = " << stacks[0] 
         << ", stacks[1] = " << stacks[1] << endl;
    cout << "포인터 표기로 두 원소에 접근\n";
    cout << "*stacks = " << *stacks
         << ", *(stacks + 1) =  " << *(stacks + 1) << endl;

    cout << sizeof(wages) << " = 배열 크기\n";
    cout << sizeof(pw) << " = pointer 크기\n";
    // cin.get();
    return 0; 
}
```

결과물
```
pw = 0x7ffd73a4c600, *pw = 10000
pw 포인터에 1을 더함:
pw = 0x7ffd73a4c608, *pw = 20000

ps = 0x7ffd73a4c5fa, *ps = 3
ps 포인터에 1을 더함:
ps = 0x7ffd73a4c5fc, *ps = 2

배열 표기로 두 원소에 접근
stacks[0] = 3, stacks[1] = 2
포인터 표기로 두 원소에 접근
*stacks = 3, *(stacks + 1) =  2
24 = 배열 크기
8 = pointer 크기
```

### 4.8.1 프로그램 분석

```
double * pw = wage;
```
pw 는 double 형을 지시하는 포인터로 선언하고 그 배열의 첫 번째 원소의 주소인 wages로 초기화한다.

배열표기 stacks[1]을 살펴보면 *(stacks +1)과 완전하게 동등한 것으로 취급한다.

*(stacks +1)은 배열의 두 번째 원소의 주소를 계산하고 그곳에 저장된 값을 알아낸다 

그 결과는 stacks[1]과 완전하게 동등하다. 즉  stacks[1] = *(stacks +1) (소괄호가 반드시 있어야한다)


    *배열 vs 포인트
    
    1. 배열 이름은 값을 변경할 수 없는 상수
    포인터는 값을 변경할 수 있는 변수
    2. 배열 이름에 sizeof 연산자를 적용하면 배열의 크기가 얻어지지만
    포인터에 sizeof 연산자를 적용하면 비록 그 포인터가 배열을 지시하고 있더라도 
    포인터의 크기가 얻어진다

요약하면

    new 연산자를 사용하여 동적 배열을 생성하고, 포인터를 사용하여 그 배열의 
    원소에 개별적으로 접근하는 것은 어렵지 않다. 포인터를 배열 이름처럼 사용
    하면 된다. 그런데 그것이 어떻게 동작하는지를 이해하는 것은 간단한 문제가 아니다
    배열과 포인터를 완전히 이해하려면, 둘 사이의 상호 관계를 더 자세히 알아이한다.

### 4.8.2 포인터와 문자열 

C++에서 포인터는 변수의 메모리 주소를 가리키는 변수입니다. 문자열은 문자 배열로 표현되며, 문자열의 첫 번째 문자 메모리 주소를 가리키는 포인터를 사용하여 문자열을 참조할 수 있습니다.

예를 들어, 다음 코드는 문자열 "Hello, world!"를 선언하고, 문자열의 첫 번째 문자 메모리 주소를 가리키는 포인터 `myString`를 선언합니다.

```
char myString[] = "Hello, world!";
```

포인터 `myString`을 사용하여 문자열의 각 문자를 참조할 수 있습니다. 예를 들어, 다음 코드는 포인터 `myString`을 사용하여 문자열의 첫 번째 문자 `H`를 출력합니다.

```
cout << *myString;
```

출력:

```
H
```

포인터는 문자열을 처리하는 데 매우 유용한 도구입니다. 포인터를 사용하여 문자열을 복사하거나, 문자열을 비교하거나, 문자열을 조작할 수 있습니다.

또한 strcpy() 함수는 한 위치의 문자열을 다른 위치로 복사한다.

예시 코드로

```
// ptrstr.cpp -- using pointers to strings
#include <iostream>
#include <cstring>              //  strlen(), strcpy()선언
int main()
{
    using namespace std;
    char animal[20] = "bear";   // animal에  bear가 들어있다
    const char * bird = "wren"; // bird 에 문자열의 주소가 들어있다
    char * ps;                  // 초기화x

    cout << animal << " and ";  //  bear 출력
    cout << bird << "\n";       //  wren 출력
    // cout << ps << "\n";      //쓰레기임 출력 x

    cout << "Enter a kind of animal: ";
    cin >> animal;              //  20 dlsodudigksek
    // cin >> ps; 절대 하지마라
   

    ps = animal;                // set ps 를 문자열을 지시하도록 설정
    cout << ps << "!\n";       // ok, same as using animal
    cout << "Before using strcpy():\n";
    cout << animal << " at " << (int *) animal << endl;
    cout << ps << " at " << (int *) ps << endl;

    ps = new char[strlen(animal) + 1];  // 새 메모리를 대입
    strcpy(ps, animal);         // 새 메모리에 문자열을 복사
    cout << "After using strcpy():\n";
    cout << animal << " at " << (int *) animal << endl;
    cout << ps << " at " << (int *) ps << endl;
    delete [] ps;
    // cin.get();
    // cin.get();
    return 0; 
}
```
출력물
```
bear and wren
Enter a kind of animal: fox
fox!
Before using strcpy():
fox at 0x7ffe0399d600
fox at 0x7ffe0399d600
After using strcpy():
fox at 0x7ffe0399d600
fox at 0x55878f7ae6d0
```


### 4.8.3 new를 사용한 동적 구조체의 생성

    new라는 연산자를 사용하여 동적 구조체를 생성할 수 있다 여기서 
    "동적" 이라는 말은 컴파일 시간이 아닌 실행 시간에 메모리를 대입반는다는 것을 뜻한다

* new를 구조체에 사용할 때에 알아야할 두 가지

```
1. 구조체를 생성하려면 구조체형 앞에다 new를 붙인다
   ex) inflatable * ps = new inflatable;

2. 맴버에 접근
동적 구조체에는 도트(.) 맴버 연산자를 사용할 수 없다
그 이유는  동적 구조체에는 이름이 없기 때문이다. 우리는 구조체의 주소만 알 수 있다.

해결방안) 화살표 맴버 연산자(->)를 제공한다
화살표 맴버 연산자는 구조체를 지시하는 포인터와 함께 사용한다
ex)
inflatable * ps = new inflatable;
ps ->price // ps가 지시하는 구조체의 price 맴버이다.

다른 접근 방법)
(*ps).price;
```

* new와 delete를 사용하는 이유

getname() 이 함수는 입력 문자열을 일단 큰 임시 배열에 읽어들인 다음 적당한 크기를 가지고 new [] 를 사용하여 그 입력 문자열의 길이에 꼭 맞는 크기의 메모리 블록으로 대입한다 
그러고 나서 그 메모리 블록을 지시하는 포인터를 리턴한다 이러한 접근은 많은 개수의 문자열을 읽어들어야 하는 프로그램에서 메모리를 크게 절약한다.

예를 들어, 프로그램이 1000개의 문자열을 읽어들여야 한다고 가정하자. 그중에서
가장 긴 문자열은 79개의 문자로 되어 있으나, 대부분의 문자열이 그것보다 길이가
훨씬 짧다고 가정하자, 

문자열을 저장하기 위해 char형의 배열을 사용한다면 크기가 80인 char형의 배열을 1000개나 만들어야 한다. 이를 위해서는 전체 8000
바이트(80KB)가 필요하다. 이렇게 할 경우에 대부분의 메모리 공간이 사용되지 없
고 버려질 것이다.

이보다 좋은 대안은 char형을 지시하는 1000개의 포인터를 원소로 가지는 배열
을 만드는 것이다. 그런 다음, 문자열마다 new를 사용하여 각 문자열의 크기에 및
는 메모리 블록을 대임하고, 각 블록의 주소를 포인터 배열의 각 원소에 대입한다
이렇게 하면 적어도 수만 바이트를 절약할 수 있다. 문자열마다 하나씩 커다란 배열
을 사용하는 대신에, 이 방법은 입력 문자열의 크기에 꼭 맞게 메모리를 대입할 수
있다.

또한 필요한 포인터 개수만큼 저장할 수 있는 공간을 확보하는 데에도 new를
사용할 수 있다. 


### 4.8.4 자동 공간, 정적 공간, 동적 공간

C++에서 자동 공간, 정적 공간, 동적 공간은 메모리를 관리하는 방식에 따라 구분됩니다.

```
자동 공간은 함수의 지역 변수에 할당되는 메모리 공간입니다. 함수가 호출되면 자동 공간이 할당되고, 함수가 종료되면 자동 공간이 해제됩니다.
정적 공간은 프로그램의 실행 기간 동안 계속 존재하는 메모리 공간입니다. 정적 변수와 전역 변수는 정적 공간에 할당됩니다.
동적 공간은 프로그램이 실행되는 동안에 필요에 따라 할당되고 해제되는 메모리 공간입니다.
new 연산자로 동적 메모리를 할당하고, delete 연산자로 동적 메모리를 해제합니다.
```

자동 공간, 정적 공간, 동적 공간은 다음과 같은 특징을 가지고 있습니다.

```
    자동 공간: 함수의 지역 변수에 할당, 함수 호출 시 할당, 함수 종료 시 해제
    정적 공간: 프로그램 실행 기간 동안 계속 존재, 정적 변수와 전역 변수에 할당
    동적 공간: 필요에 따라 할당 및 해제, new 연산자로 할당, delete 연산자로 해제
```

C++에서 메모리 공간을 선택하는 방법은 다음과 같습니다.

```
지역 변수는 자동 공간에 할당하는 것이 일반적입니다.
정적 변수는 프로그램 실행 기간 동안 계속 존재해야 하므로 정적 공간에 할당하는 것이 좋습니다.
동적 변수는 크기가 가변적이거나 사용 빈도가 높을 경우 동적 공간에 할당하는 것이 좋습니다.
자동 공간, 정적 공간, 동적 공간은 C++에서 메모리를 관리하는 데 중요한 역할을 합니다. 각 공간의 특징을 이해하고 적절하게 사용하면 효율적인 메모리 관리가 가능합니다.
```

## 4.9 변수형의 조합

배열, 구조, 포인트 이 세 가지는 매우 다양한 방법으로조합될 수 있다.


```
struct years_end
{
int years;
};
years_end s01, 502, s03;  // s01, 502, s03 모두 구조체이다

s01.year = 2023; // 맴버에 접근

years_end * pa = &s02;   //포인터가 유효한 주소를 가리킬 경우 간접적인 맴버십 연산자를 사용하여 맴버에 접근 가능
pa ->year = 2023;


years_end trio[3];       // trio[0]는 구조체이다. trio는 배열이나 trio[0]는 구조체다 trio[0].year은 구조체 맴버다

(trio+1) ->year = 2004;       //trio[1].year=2004와 동일

const year_end * arp[3] = {%s01, &s02, &s03}; //포인터 배열
std::cout << arp[1]->year << std::endl;  //그 포인터의 간접 맴버십 연산자를 사용하여 멤버에 접근

const years_end ** ppa = arp;   //배열에 대한 포인터를 생성 arp[0]은 포인터이므로 ppa는 **가 되어야한다

// 복잡한거 해결 방법 conset를 빼먹고 하나의 순서 뒤바꿈 함수인 *나 두 개의 **를 잊어버리거나
// 다른 구조형과 혼합할 수 있다.

auto ppb = arp; // 자동으로 변수 형을 확인

// ppa는 구조체의 포인터를 가르키는 포인터 *ppa는 구조체를 가리키는 포인터
std::cout <<(*ppa)->year << std::endl;
std::cout <<(*(ppb+1))->year << std::endl;
```
ppa는 arp의 첫 번째 멤버를 가리키는 포인터이기 때문에, *ppa는 그첫 번째
멤버로 &s01이다. 그러므로, ( *ppa) ->year는 s01의 year 맴버이다.

두 번째 구문에서 ppb+1은 다음 요소인 arp[1] 을 지목하는데, 그것이 &s02이다. 
괄호는 정확한 관계를 얻기 위해서 필요하다. 

예를 들어, *ppa->year는 * 운영자를 ppa->year에 적용하려는 시도를 하는데, year 멤버가 포인터가 아니기 때문에
성공할 수 없다. 

*예시 코드

```
// mixtypes.cpp --some type combinations
#include <iostream>

struct antarctica_years_end
{
    int year;
 /* some really interesting data, etc. */
};

int main()
{
    antarctica_years_end s01, s02, s03; 
    s01.year = 1998;
    antarctica_years_end * pa = &s02;
    pa->year = 1999;
    antarctica_years_end trio[3]; // array of 3 structures
    trio[0].year = 2003;
    std::cout << trio->year << std::endl;
    const antarctica_years_end * arp[3] = {&s01, &s02, &s03};
    std::cout << arp[1]->year << std::endl;
    const antarctica_years_end ** ppa = arp; 
    auto ppb = arp; // C++0x automatic type deduction
// or else use const antarctica_years_end ** ppb = arp; 
    std::cout << (*ppa)->year << std::endl;
    std::cout << (*(ppb+1))->year << std::endl;
    // std::cin.get();
    return 0;
}
```
실행 결과
```
2003
1999
1998
1999
```
## 4.9 배열의 대안

### 4.9.1 Vector 템플릿 클래스

C++에서 Vector 템플릿 클래스는 동적으로 크기가 조절되는 배열을 제공하는 클래스입니다. Vector 템플릿 클래스는 다음과 같은 특징을 가지고 있습니다.

* 동적으로 크기가 조절됩니다.
* 다양한 데이터 타입을 저장할 수 있습니다.
* 다양한 연산을 수행할 수 있습니다.

다음은 Vector 템플릿 클래스를 사용하여 배열을 생성하고 값을 저장하고 출력하는 예시 코드입니다.

```c++
#include <vector>

int main() {
  std::vector<int> v;
  v.push_back(1);
  v.push_back(2);
  v.push_back(3);

  for (int i = 0; i < v.size(); i++) {
    std::cout << v[i] << std::endl;
  }

  return 0;
}
```

이 코드는 다음과 같이 출력됩니다.

```
1
2
3
```

Vector 템플릿 클래스는 C++에서 배열을 다루는 데 유용한 클래스입니다. 다양한 데이터 타입을 저장하고 다양한 연산을 수행할 수 있으므로 코드를 간결하고 효율적으로 작성할 수 있습니다.

### 4.9.2 array 탬플릿 클래스

C++에서 array 템플릿 클래스는 고정 크기의 배열을 제공하는 클래스입니다. array 템플릿 클래스는 다음과 같은 특징을 가지고 있습니다.

* 고정 크기의 배열을 제공합니다.
* 다양한 데이터 타입을 저장할 수 있습니다.
* 다양한 연산을 수행할 수 있습니다.

다음은 array 템플릿 클래스를 사용하여 배열을 생성하고 값을 저장하고 출력하는 예시 코드입니다.

```c++
#include <array>

int main() {
  std::array<int, 3> v = {1, 2, 3};

  for (int i = 0; i < v.size(); i++) {
    std::cout << v[i] << std::endl;
  }

  return 0;
}
```

이 코드는 다음과 같이 출력됩니다.

```
1
2
3
```

array 템플릿 클래스는 C++에서 배열을 다루는 데 유용한 클래스입니다. 고정 크기의 배열을 제공하므로 코드를 간결하고 효율적으로 작성할 수 있습니다.

### 4.9.3 배열, Vector 객체, Array 객체 비교

배열, Vector 객체, Array 객체는 모두 C++에서 데이터를 저장하는 데 사용되는 자료구조입니다. 배열은 고정 크기의 데이터를 저장하는 자료구조이고, Vector 객체는 동적으로 크기가 조절되는 데이터를 저장하는 자료구조이고, Array 객체는 C++11에서 도입된 고정 크기의 데이터를 저장하는 자료구조입니다.

| 특징 | 배열 | Vector 객체 | Array 객체 |
|---|---|---|---|
| 크기 | 고정 | 동적 | 고정 |
| 메모리 할당 | Stack | Heap | Stack |
| 메모리 관리 | 컴파일러 | 런타임 | 컴파일러 |
| 성능 | 빠름 | 느림 | 빠름 |
| 사용 용도 | 정해진 크기의 데이터를 저장해야 할 때 | 크기가 가변적인 데이터를 저장해야 할 때 | 정해진 크기의 데이터를 저장해야 할 때 |

배열은 가장 빠른 성능을 가지지만, 크기가 고정되어 있기 때문에 크기가 가변적인 데이터를 저장하기에는 적합하지 않습니다. Vector 객체는 크기가 가변적이기 때문에 배열보다 다양한 데이터를 저장할 수 있지만, 성능은 배열보다 느립니다. Array 객체는 C++11에서 도입된 자료구조이기 때문에 가장 최신 기능을 제공하지만, 아직까지는 지원하지 않는 컴파일러가 많습니다.

배열, Vector 객체, Array 객체는 모두 C++에서 데이터를 저장하는 데 사용되는 자료구조이지만, 각 자료구조마다 특징이 다르기 때문에 사용 용도에 따라 적절한 자료구조를 선택하는 것이 중요합니다.


















