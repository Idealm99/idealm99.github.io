<a class="anchor" id="0"></a>
# **C++**
**1차 보고서**
<a class="anchor" id="0.1"></a>

# **목차**


[1. c++ 첫걸음](#1)

[2. c++ 시작하기](#2)

[3. 데이터 처리](#3)

[4. 복합 데이터형](#4)

[5. 루프와 관계 표현식](#5)

---

# 1장 c++ 첫걸음<a class="anchor" id="1"></a>

## 1.1 c++ 사용하는 이유

    1.효율적이며,크기가 작고 실행 속도가 빠르며 이식성이 뛰어난 c를 그대로 물려받았다 
    2. 객체지향을 지원한다.
    3. 일반화 프로그래밍 추가

## 1.2 객체 지향 프로그래밍

    구조적 프로그래밍 철학이 프로그램의 간결성, 신뢰성 유지 보수의 용이성에 많은 향상을 가져왔지만 
    규모가 큰 프로그래밍은 여전히 어렵다. 
    이 문제를 해결하기 위해서 객체 지향 프로그래밍 철학이 등장했다. 
    객체지향 프로그래밍은 데이터를 강조한다. 또한 언어 자체를 해결해야 할 문제에 맞춘다.
    즉 해결해야 할 문제의 특성에 맞게 데이터형 자체를 설계하는데
    c++ 에서는 class 가 그와 같은 목적으로 설계되는 새로운 데이터형이다. 
    객체를 정확하게 서술하는 클래스를 먼저 설계 해야한다. 
    저수준의 클래스를 먼저 설계한 후에 고수준의 프로그램 설계를 하는데 이를 상향식 프로그래밍이라고 한다.

## 1.3 일반화 프로그래밍

 일반화 프로그래밍과 oop는 소스코드를 재활용하고 포괄 개념의 추상화 기술을 서로 공유한다. 

## 프로그래밍 절차

![절차](https://github.com/Idealm99/idealm99.github.io/assets/112872986/2d8f4946-c248-4cc3-80cf-0da3fd0dca77)

## 소스 코드의 파일 이름 구성 요소

    spiffy.ccp 

    spiffy는 기본 파일 이름 ccp는 확장자이다.

### 소스코드의 확장자 종류

![KakaoTalk_20230705_144418983](https://github.com/Idealm99/idealm99.github.io/assets/112872986/f367c924-83a8-4784-82e6-5ec6eb243a01)

## 컴파일러

   Unix는 CC 대문자임

# 2장 c++ 시작하기<a class="anchor" id="2"></a>

## main() 함수 

     int main()
     {
          구문들
          return 0;
     }
    
기본적으로 이러한 형태를 가지고 있다.
c++에서는 모든 구문이 끝날 때 세미콜론(;)을 붙여야한다.
그리고 main() 함수의 끝에 있는 구문은 return 구문이다. 이것은 함수를 종료하는 역활을 한다.

    int main 이 부분을 함수 이름 (인자리스트, 매개변수 리스트 ) 괄호 안의 이름들이다.

    int main(void) 괄호 안에 void가 있는것은 그 함수가 다른 함수로부터 어떠한 정보도
    전달받지 않는다는 것을 명시적으로 밝히는 것이다.
    // 괄호 안을 비워두는 것은 괄호 안에 void가 있는 것과 같다
    
    주석은 // 를 붙이면 된다 이것은 컴파일러가 읽지 않는다.

## c++ 전처리기와 iostream 파일

     #include <iostream>    // 전처리 지시자
     이 지시자는 전처리기에게 iostream 파일의 내용을 프로그램에 추가하라고 지시한다.

그렇다면 왜 iostream 파일의 내용을 프로그램에 추가할까?

     그 이유는 프로그램 바깥 세상이 정보를 주고받을 수 있도록 하기 위해서다.
     count을 사용하려면 이러한 정의가 필요하다
     **cout은 printf와 비슷한 것이다**

## 이름 공간

다음과 같은 이름 공간 지시자를 사용한다. 그러면 iostream.h 대신에 iostream을 사용할 수 있게 해준다.

     using namespace std;
     
이것을 using 지시자라 한다.
그리고 위에 코드를 작성하면 

    std::cout << " 이렇게 using 지시자를 생략하고 작성할 수 있다.";
    std::cout << std::endl;

## cout 을 이용한 출력

cout << (문자열,수,문자); 에서 << 는 (문자열,수,문자)를 cout에 전달한다는 것을 뜻한다.

새로운 행으로 시작하는 방법은
    *조정자 endl은 새로운 행이 시작된다는 코드이다.
    *다른 방법으로는 cout << " 다음 행으로 |n"; |n 이 있다.

### cout의 새로운 사용법

    int carrots = 25;
    cout << carrots;

위 코드는 crrots라는 단어를 출력하지 않고 변수 carrots에 현재 저장되어 있는 값인 정수 25를 출력한다

    1. cout은 carrots 를 정수 25로 대체한다
    2. 정수 25를 적당한 출력 문자 '2' '5'로 변환한다.
    
이처럼 cout는 문자열뿐만 아니라 정수도 출력할 수 있다. cout은 carrots가 변환할 필요가 있는 정수라는 사실을 알고 있다

    
## c++ 소스코드 모양

    #include <iostream>
        int
    main
    () {   using
         namespace
             std;  cout
                 <<
      "이게 가능하다고?"
      ;   cout <<
      endl; erturn 0;}

이렇게 작성하는 것도 가능하다.

    int ma in()       // 이름 안에 빈칸이 있어서 틀리다
    re
    turn 0;           // 키워드 안에 캐리지 리턴이 있어서
    cout << "Behold the Beans
    of Beauty!";      //문자열 안에 캐리지 리턴이 있어서 틀리다

## cin을 이용한 입력 

    cin >> carrots; 
    
 이 코드로 cin에 있는 값을 carrots 쪽으로 흐른다는 것을 보여주는 코드다
 
 cin은 키보드로 넣은 일련의 문자들인 입력을 그것을 저장할 변수가 받아들이는 형태로 바꾼다.

## cout에 의한 출력의 결합

iostream 파일에는 << 연산자가 여러 개의 출력을 하나로 결합(연결)
있도록 정의되어 있다

    cout << "이제 당근은 모두 " << carrots << "개이다." << endl;

이것은 문자열 출력과 정수 출력을 하나의 구문으로 결함한다. 이것의 실행 결
다음과 같은 세 행의 코드가 만들어 내는 결과와 동일하다.

    cout << "이제 당근은 모두"; 
    cout << carrots;
    cout << "개이다.";
    cout << endl;

또한 독자가 cout 을 사용하리는 권고를 받아들이기로 했다면, 하나로 결합된 .
구문을 다음과 같이 네 행에 결쳐 작성할 수도 있다.

    cout << "이제 당근은 모두"
    << carrots
    << "개이다."
    << endl; 
  

## 함수

C++에는 함수의 유형이 2가지가 있다.

    1. 리턴값이 있는 것과 리턴값이 없는 것
    2. 표준 함수 라이브러리에 있는 함수를 사용할 수도 있고 사용자가 직접 만들어 사용할 수도 있다.

### 리턴값이 있는 함수

리턴값이 있는 함수는 변수에 대입할 수 있는 하나의 값을 만들어 낸다.

![sqrt](https://github.com/Idealm99/idealm99.github.io/assets/112872986/28e03538-3844-4239-b605-2e04f83d244a)

함수가 잡업을 끝내면 구문에 있는 함수 호출이 그 리턴값으로 대체된다.

즉 매게변수는 함수에 전달되는 정보이고, 리턴값은 함수가 돌려주는 값이다

실수를 c++에서는 double형으로 나타낸다 

    double sqrt(double);   //함수원형
    앞의 double은 sqrt() 함수가 double형의 값을 리턴한다는 뜻이고
    뒤의 double은 sqrt() 함수가 double형의 매개변수를 전달받는다는 뜻이다.

    double x;        // x를 double형 변수로 선언한다.
    x = sqrt(6.25);
    
### 변이 함수들

    double pow (double , double);   //2개의 매개변수를 가진 함수 원형
    int rand(void);                 // 매개변수가 없는 함수 원형
    myGuess = rand();               // 매개변수가 없는 함수 호출
    void bucks(double);             // 리턴값이 없는 함수 원형
    bucks(1.54);                    // 리턴값이 없는 함수 호출

### 사용자 정의 함수

    #include <iostream>
    void simon(int);
    int main() 
    {
        using namespace std;
        simon(3);
        return 0;
    }
    void simon( int n)
    {
       using namespace std;
       cout << "simon 왈 발가락을" << n << "번 두드려라." << endl;
    }

    출력물
    simon 왈 발가락을 3번 두드려라.

이러한 결과물이 된다 simon이라는 함수를 만들고 void simon( int n)에서 () 안에 입력받을 변수 타입을 정해주고
 main에서 함수를 호출하면 이렇게 simon함수 안에 있는 것들이 실행된다.

 만약 simple - simon(3); 이면 void형 함수이므로 이렇게 사용할 수 없다.
 
 ### 리턴값이 있는 사용자 정의 함수

 
# 3장 데이터 처리<a class="anchor" id="3"></a>

## 변수 이름

    * 변수 이름에는 영문자,숫자,밑줄 문자만을 사용할 수 있다.
    * 숫자를 변수 이름의 첫 문자로 사용할 수 없다.
    * 변수 이름에 대문자와 소문자는 구별된다
    * C++의 키워드는 변수 이름으로 사용할 수 없다
    * 두개의 밑줄 문자로 시작하는 이름이나 밑줄 문자와 대문자로 시작하는 이름은 그것을 사용하는 컴파일러와 리소스가
    하나의 밑줄은 컴파일러와 리소스가 전역 식별자로 사용
    * 변수 이름의 제한이 없으며 변수 이름에 쓰인 모든 문자들이 유효하다.

## 정수형 

정수는 2, 54 87 같이 소수부가 없는  수를 말한다. 그런데 컴퓨터의 메모리 용향에는 한계가 있으므로 길이가 제한된다.
양수값과 음수값 모두 나타낼 수 있으나 unsigned 데이터형은 양수값만 나타낼 수 있다.
기본 정수형 크기 순서로는

    char < short < int < long < long long 순이다.
    *short 16bit
    *int 32bit
    *long long 64bit more

    선언 방법

    *short score;
    *int score;
    *long score;

### 데이터 크기 알아내는 방법

1. sizeof 연산자 데이터형의 크기를 바이트 단위로 리턴한다
2. climits 헤더 파일 열어 보는 방법

climits에 정의되어 있는 기호 상수들

![climits](https://github.com/Idealm99/idealm99.github.io/assets/112872986/3d32c2af-3fa2-4be2-aba9-c439cab06e9a)

### 초기화 

초기화는 선언과 대입을 하나로 조합한다. 에로

    int n_int = INT_MAX;
    int uncle = 5; //uncle 5로 초기화
    int uncle(5);  // C++의 새로운 초기화 문법

## unsigned 형

C++ 의 unsigned 형은 부호가 없는 정수형입니다. 부호가 없는 정수는 양수만 저장할 수 있습니다. unsigned 형의 범위는 부호가 있는 정수형의 범위보다 큽니다. 예를 들어, unsigned int 의 범위는 0 ~ 4294967295 이고, int 의 범위는 -2147483648 ~ 2147483647 입니다.

unsigned 형을 사용하는 이유는 다음과 같습니다.

* 양수만 저장해야 할 때
* 부호가 있는 정수형보다 더 큰 범위의 정수를 저장해야 할 때
* 부호 오류를 방지해야 할 때

unsigned 형을 사용할 때는 다음과 같은 점에 유의해야 합니다.

* unsigned 형은 부호가 없는 정수형이기 때문에 음수를 저장할 수 없습니다.
* unsigned 형과 부호가 있는 정수형을 연산할 때는 부호가 있는 정수형을 unsigned 형으로 변환합니다.
* unsigned 형과 부호가 있는 정수형의 범위가 다르기 때문에 unsigned 형으로 변환할 때는 주의해야 합니다.

unsigned 만 있는 것은 unsigned int 를 줄여서 나타낸 것이다.

## C++가 상수의 데이터형을 결정하는 방법

1. 상수의 값을 기준으로 데이터형을 결정합니다.
2. 상수의 이름에 접미어를 붙여 데이터형을 지정할 수 있습니다.
3. 상수의 데이터형을 명시적으로 지정할 수 있습니다.

예를 들어, 상수의 값이 100이면 int형으로 결정됩니다. 상수의 이름에 접미어를 붙여 데이터형을 지정할 수도 있습니다. 예를 들어, `const int a = 100;`은 int형 상수 `a`를 선언합니다. 상수의 데이터형을 명시적으로 지정할 수도 있습니다. 예를 들어, `const int a = 100u;`은 unsigned int형 상수 `a`를 선언합니다.

### char 형 문자와 작은 정수

문자와 숫자를 저장하기 위한 형태이다.

char형은 문자들을 처리하는데 사용할 수도 있다.

예를 들어서 ASCII 에서 A는 65다

    char ch= 65;
    cout << ch

    출력물 = A
    

입력할 때 문자 A에 해당하는 코드인 65을 ch에 입력하면 숫자가 아닌 그에 해당하는 문자인 A가 나온다.
이것은 char가 바꾸는 것이 아닌 cout에서 변환하는 것이다.

cout.put(A);은 ASCII로 변환하지 않고 문자 그대로 나오게 한다.

    char alarm = '|a';
    cout << alarm << "틀렸습니다!|a|n";
    cout << "정답은|n 김소월의 |"진달래 꽃|"입니다!|n";

    *실행 결과*
    정답은
    김소월의 "진달래 꽃"입니다!

![이스케이프](https://github.com/Idealm99/idealm99.github.io/assets/112872986/12d4b318-0e96-4ff9-a916-49945f47a8db)

signed char , unsigned char

int 형과 달리 char 형은 signed 형이나 unsigned형으로 미리 정해져 있지 않다.
그러나 char 형이 어느 특별한 한 가지 행도만을 보여야 한다면 

signed char bar;

unsigned char bar;
로 나타내면 된다.

#### wchar_t, char16_t, char32_t

C++의 wchar_t, char16_t, char32_t는 모두 멀티바이트 문자를 저장하기 위한 데이터 타입입니다. wchar_t는 가장 일반적인 멀티바이트 문자 타입으로, UCS-2 코드 포맷을 사용합니다. char16_t는 UTF-16 코드 포맷을 사용하며, char32_t는 UTF-32 코드 포맷을 사용합니다.

wchar_t는 UCS-2 코드 포맷을 사용하기 때문에, UCS-2 코드 포맷에 해당하는 문자만 저장할 수 있습니다. char16_t는 UTF-16 코드 포맷을 사용하기 때문에, UTF-16 코드 포맷에 해당하는 문자만 저장할 수 있습니다. char32_t는 UTF-32 코드 포맷을 사용하기 때문에, UTF-32 코드 포맷에 해당하는 모든 문자를 저장할 수 있습니다.

wchar_t, char16_t, char32_t는 모두 문자열을 저장하기 위한 데이터 타입이므로, char 타입과 마찬가지로 문자열 연산을 수행할 수 있습니다. 예를 들어, wchar_t, char16_t, char32_t 타입의 문자열을 연결하거나, 문자열의 길이를 구하거나, 문자열을 비교하는 등의 연산을 수행할 수 있습니다.

wchar_t, char16_t, char32_t는 모두 char 타입보다 메모리 공간을 더 많이 차지합니다. 따라서, 문자열의 크기가 크지 않은 경우에는 char 타입을 사용하는 것이 더 효율적일 수 있습니다.

### bool형 

bool형은 true 또는 false 형으로 나오게 하는 데이터형인데 하나의 값만 가질 수 있다.

## const 제한

기호상수를 다르는 방법이고 const 키워드를 사용하여 변수를 선언하고 초기화하는 것이다.
예를 들어서 1년의 달 수를 기호 상수로 나타내고 싶다면 프로그램에 다음과 같은 행을 넣으면 된다.

    const int MONTHS = 12;

이후 MONTHS에 어떠한 변경을 할려고 해도 가능하지 않고 에러가 뜬다 . 3이라는 수를 4로 바꿀려고 하는 것과 같다.

그리고 선언할 때 초기화해야한다!!

## 부동 소수점수

### 부동 소수점 표

2.52e+8    // E 또는 e를 사용할 수 있으며 +는 생략할 수 있다
8.33F-4    // 지수는 음수일 수도 있다
7E5        // 7.0+05와 같다
-18. 32e13 // 앞에 +나 - 부호를 넣을 수 있다
1.69e12    // 2010년 브라질 공채 (브라질 통화 기준: reais)
5.98E24    // 킬로그램 단위로 지구의 질량
9.11e-31   // 킬로그램 단위로 전자의 질량.

### 부동 소수점형

              float , double  , long double
    최소 비트 : 32      48         80,96,128

### 부동 소수점형 상수

부동 소수점형 상수를 float 형으로 저장하고 싶으면 F,f 점미어로 
long double 형으로 저장하고 싶으면 L,l 점미어로 사용해라

    예
    1.234f
    1.234F
    1.234L
    1.234l l대신에 L을 사용해라

### 부동 소수점의 장단점

1. 정수와 정수 사이에 있는 값을 나타낼 수 있다.
2. 스케일을 사용하여 매우 큰 범위의 값을 나타낼 수 있다.
그러나 부동 소수점수 연산은 수치 연산 보조 프로새서 없는 컴퓨터에서 정수 연산보다 속도가 느리다.

    // fltadd.cpp -- float형에서의 정밀도 손실 문제
    #include <iostream>
    int main ()
   {
    using namespace std;
    float a = 2.34+22f;
    float b=a + 1.0f;
    cout << "a = " << a << endl;
    cout << "b - a = " << b - a << endl;
    return 0;
   }
   

프로 그램은 어떤 수에 1을 더한 후 원래의 수를 뺀다. 예상되는 결과는 1
이어야 한다. 그러나 실제로 그럴까? 다음은 우리가 사용한 시스템에서 
프로그램을 실행한 결과이다.

    a p 2.34e+022
    b - a = 0

이렇게 결과가 나온 이유는 2.34E+22가 소수점 위로 23개의 숫자를 가진 큰 수이기 때문에 발생한 것이다.
이 수에 1을 더하는 것은 23번째 숫자에 1을 더하는 것과 같다 
float형은 처음 6개의 숫자 또는 7개의 숫자까지만 나타낼 수 있으므로 23번째 숫자에 1을 더하는 것은
아무런 효과도 갖지 못한다.

## C++ 산술 연산자

    +, -, *, /, % 
    + : 두개의 피연산자를 더한다
    - : 두개의 피연산자를 뺀다
    * : 두개의 피 연산자를 곱한다
    / : 두개의 피 연산자를 나눈다
    % : 두개의 피 연산자를 나누고 나머지를 구한다.

### 연산 순서 : 우선순위와 결합 방향

(*,/,%) > +, - 같은 우선순위는 앞에 있는 연산자 먼저

### 나눗셈에 대한 보충

    정수 나s눗셈: 9/5 = 1
    부동 소수점수 나눗셈: 9.0/5.0 = 1.800000
    혼합 나눗셈: 9.0/5 = 1.800000
    double형 상수: 1e7/9.0 = 1111111.111111
    fioat형 상수: 1e7f/9.0f = 1111111.125000

### 데이터형 변환

C++에서 데이터형 변환은 변수나 값의 데이터형을 다른 데이터형으로 변환하는 과정을 의미합니다. 데이터형 변환은 때로는 필요한 연산을 수행하거나 변수를 다른 형식으로 표현해야 할 때 유용합니다. C++에서는 명시적(explicit) 변환과 암시적(implicit) 변환 두 가지 유형의 데이터형 변환을 지원합니다.

암시적 변환(묵시적 변환, Implicit Conversion):
암시적 변환은 컴파일러가 자동으로 수행하는 데이터형 변환이며, 컴파일러가 허용하는 변환 규칙을 따라 수행됩니다. 일반적으로 작은 크기의 데이터형에서 큰 크기의 데이터형으로의 변환이나 정밀도 손실이 없는 변환 등이 암시적으로 처리됩니다. 예를 들어, 정수에서 실수로의 변환, 작은 정수형에서 큰 정수형으로의 변환 등이 암시적 변환이 될 수 있습니다.


    int num1 = 10;
    double num2 = num1;  // 암시적 변환: int를 double로 변환
    
명시적 변환(명시적 형변환, Explicit Conversion):
명시적 변환은 프로그래머가 직접 지정하여 수행하는 데이터형 변환으로, 명시적으로 변환 연산자를 사용해야 합니다. 이러한 변환은 데이터의 손실이 발생하거나 특정 연산을 수행하기 위해 필요한 경우에 사용됩니다. C++에서는 C 스타일의 형변환과 C++ 스타일의 형변환(deprecated) 두 가지 방법으로 명시적 변환이 가능합니다.

C 스타일 형변환:
C 스타일의 형변환은 기존 C 언어에서 사용되던 형식으로, (타입) 형태로 표현됩니다.

    double num1 = 3.14;
    int num2 = (int)num1;  // 명시적 변환: double을 int로 변환
    
C++ 스타일 형변환 (deprecated):
C++에서는 C 스타일 형변환 대신, C++ 스타일의 형변환을 권장합니다. C++ 스타일 형변환은 다음 네 가지 형태로 사용될 수 있습니다.

static_cast<타입>(표현식): 일반적인 형변환에 사용되며, 컴파일 타임에 검사됩니다.
dynamic_cast<타입>(표현식): 클래스 계층 구조에서의 형변환에 사용되며, 실행 중에 타입을 검사합니다.
reinterpret_cast<타입>(표현식): 포인터 타입 사이의 형변환에 사용되며, 주소 값을 바꾸거나 포인터 크기를 변경하는 데 사용됩니다.
const_cast<타입>(표현식): const 한정자를 추가하거나 제거하기 위한 형변환에 사용됩니다.


    double num1 = 3.14;
    int num2 = static_cast<int>(num1);  // 명시적 변환: double을 int로 변환
    
#### 표현 방법

구식은 (int) 1.32
신식    int (1.32)

### auto 선언

초기화 선언시 테이터형을 쓰지 않고 auto를 사용할 수 있다.

    auto n =100;  //n은 정수
    auto n =100.2;  //n은 double
    auto n =10.3e12L;  //n은 long double

하지만 이것만 쓰는 것은 좋지 않다 왜냐하면.

0.0 대신에 0을 사용하는 경우 문제가 발생할 수 있다. (나중에 9장에서 자세하게 다룹니다.)

# 4장 복합형 데이터


 
