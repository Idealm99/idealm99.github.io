---
layout: single
title:  "2023 C++ 1차 보고서"
categories: coding
toc: true
author_profile: false
---

<head>
<link rel="stylesheet" href="toc.css">
  <style>
    table.dataframe {
      white-space: normal;
      width: 100%;
      height: 240px;
      display: block;
      overflow: auto;
      font-family: Arial, sans-serif;
      font-size: 0.9rem;
      line-height: 20px;
      text-align: center;
      border: 0px !important;
    }

    table.dataframe th {
      text-align: center;
      font-weight: bold;
      padding: 8px;
    }

    table.dataframe td {
      text-align: center;
      padding: 8px;
    }

    table.dataframe tr:hover {
      background: #b8d1f3; 
    }

    .output_prompt {
      overflow: auto;
      font-size: 0.9rem;
      line-height: 1.45;
      border-radius: 0.3rem;
      -webkit-overflow-scrolling: touch;
      padding: 0.8rem;
      margin-top: 0;
      margin-bottom: 15px;
      font: 1rem Consolas, "Liberation Mono", Menlo, Courier, monospace;
      color: $code-text-color;
      border: solid 1px $border-color;
      border-radius: 0.3rem;
      word-break: normal;
      white-space: pre;
    }

  .dataframe tbody tr th:only-of-type {
      vertical-align: middle;
  }

  .dataframe tbody tr th {
      vertical-align: top;
  }

  .dataframe thead th {
      text-align: center !important;
      position: sticky;
      padding: 8px;
  }

  .page__content p {
      margin: 0 0 0px !important;
  }

  .page__content p > strong {
    font-size: 0.8rem !important;
  }

  </style>
</head>

# **목차**

[1. c++ 첫걸음](#1)

[2. c++ 시작하기](#2)

[3. 데이터 처리](#3)

[4. 복합 데이터형](#4)

[5. 루프와 관계 표현식](#5)

---

# 1장 c++ 첫걸음<a class="anchor" id="1"></a>

## 1.1 c++ 사용하는 이유

    1.효율적이며,크기가 작고 실행 속도가 빠르며 이식성이 뛰어난 c를 그대로 물려받았다 
    2. 객체지향을 지원한다.
    3. 일반화 프로그래밍 추가

## 1.2 객체 지향 프로그래밍

    구조적 프로그래밍 철학이 프로그램의 간결성, 신뢰성 유지 보수의 용이성에 많은 향상을 가져왔지만 
    규모가 큰 프로그래밍은 여전히 어렵다. 
    이 문제를 해결하기 위해서 객체 지향 프로그래밍 철학이 등장했다. 
    객체지향 프로그래밍은 데이터를 강조한다. 또한 언어 자체를 해결해야 할 문제에 맞춘다.
    즉 해결해야 할 문제의 특성에 맞게 데이터형 자체를 설계하는데
    c++ 에서는 class 가 그와 같은 목적으로 설계되는 새로운 데이터형이다. 
    객체를 정확하게 서술하는 클래스를 먼저 설계 해야한다. 
    저수준의 클래스를 먼저 설계한 후에 고수준의 프로그램 설계를 하는데 이를 상향식 프로그래밍이라고 한다.

## 1.3 일반화 프로그래밍

 일반화 프로그래밍과 oop는 소스코드를 재활용하고 포괄 개념의 추상화 기술을 서로 공유한다. 

## 프로그래밍 절차

![절차](https://github.com/Idealm99/idealm99.github.io/assets/112872986/2d8f4946-c248-4cc3-80cf-0da3fd0dca77)

## 소스 코드의 파일 이름 구성 요소

    spiffy.ccp 

    spiffy는 기본 파일 이름 ccp는 확장자이다.

### 소스코드의 확장자 종류

![KakaoTalk_20230705_144418983](https://github.com/Idealm99/idealm99.github.io/assets/112872986/f367c924-83a8-4784-82e6-5ec6eb243a01)

## 컴파일러

   Unix는 CC 대문자임

# 2장 c++ 시작하기<a class="anchor" id="2"></a>

## main() 함수 

     int main()
     {
          구문들
          return 0;
     }
    
기본적으로 이러한 형태를 가지고 있다.
c++에서는 모든 구문이 끝날 때 세미콜론(;)을 붙여야한다.
그리고 main() 함수의 끝에 있는 구문은 return 구문이다. 이것은 함수를 종료하는 역활을 한다.

    int main 이 부분을 함수 이름 (인자리스트, 매개변수 리스트 ) 괄호 안의 이름들이다.

    int main(void) 괄호 안에 void가 있는것은 그 함수가 다른 함수로부터 어떠한 정보도
    전달받지 않는다는 것을 명시적으로 밝히는 것이다.
    // 괄호 안을 비워두는 것은 괄호 안에 void가 있는 것과 같다
    
    주석은 // 를 붙이면 된다 이것은 컴파일러가 읽지 않는다.

## c++ 전처리기와 iostream 파일

     #include <iostream>    // 전처리 지시자
     이 지시자는 전처리기에게 iostream 파일의 내용을 프로그램에 추가하라고 지시한다.

그렇다면 왜 iostream 파일의 내용을 프로그램에 추가할까?

     그 이유는 프로그램 바깥 세상이 정보를 주고받을 수 있도록 하기 위해서다.
     count을 사용하려면 이러한 정의가 필요하다
     **cout은 printf와 비슷한 것이다**

## 이름 공간

다음과 같은 이름 공간 지시자를 사용한다. 그러면 iostream.h 대신에 iostream을 사용할 수 있게 해준다.

     using namespace std;
     
이것을 using 지시자라 한다.
그리고 위에 코드를 작성하면 

    std::cout << " 이렇게 using 지시자를 생략하고 작성할 수 있다.";
    std::cout << std::endl;

## cout 을 이용한 출력

cout << (문자열,수,문자); 에서 << 는 (문자열,수,문자)를 cout에 전달한다는 것을 뜻한다.

새로운 행으로 시작하는 방법은
    *조정자 endl은 새로운 행이 시작된다는 코드이다.
    *다른 방법으로는 cout << " 다음 행으로 |n"; |n 이 있다.

### cout의 새로운 사용법

    int carrots = 25;
    cout << carrots;

위 코드는 crrots라는 단어를 출력하지 않고 변수 carrots에 현재 저장되어 있는 값인 정수 25를 출력한다

    1. cout은 carrots 를 정수 25로 대체한다
    2. 정수 25를 적당한 출력 문자 '2' '5'로 변환한다.
    
이처럼 cout는 문자열뿐만 아니라 정수도 출력할 수 있다. cout은 carrots가 변환할 필요가 있는 정수라는 사실을 알고 있다

    
## c++ 소스코드 모양

    #include <iostream>
        int
    main
    () {   using
         namespace
             std;  cout
                 <<
      "이게 가능하다고?"
      ;   cout <<
      endl; erturn 0;}

이렇게 작성하는 것도 가능하다.

    int ma in()       // 이름 안에 빈칸이 있어서 틀리다
    re
    turn 0;           // 키워드 안에 캐리지 리턴이 있어서
    cout << "Behold the Beans
    of Beauty!";      //문자열 안에 캐리지 리턴이 있어서 틀리다

## cin을 이용한 입력 

    cin >> carrots; 
    
 이 코드로 cin에 있는 값을 carrots 쪽으로 흐른다는 것을 보여주는 코드다
 
 cin은 키보드로 넣은 일련의 문자들인 입력을 그것을 저장할 변수가 받아들이는 형태로 바꾼다.

## cout에 의한 출력의 결합

iostream 파일에는 << 연산자가 여러 개의 출력을 하나로 결합(연결)
있도록 정의되어 있다

    cout << "이제 당근은 모두 " << carrots << "개이다." << endl;

이것은 문자열 출력과 정수 출력을 하나의 구문으로 결함한다. 이것의 실행 결
다음과 같은 세 행의 코드가 만들어 내는 결과와 동일하다.

    cout << "이제 당근은 모두"; 
    cout << carrots;
    cout << "개이다.";
    cout << endl;

또한 독자가 cout 을 사용하리는 권고를 받아들이기로 했다면, 하나로 결합된 .
구문을 다음과 같이 네 행에 결쳐 작성할 수도 있다.

    cout << "이제 당근은 모두"
    << carrots
    << "개이다."
    << endl; 
  

## 함수

C++에는 함수의 유형이 2가지가 있다.

    1. 리턴값이 있는 것과 리턴값이 없는 것
    2. 표준 함수 라이브러리에 있는 함수를 사용할 수도 있고 사용자가 직접 만들어 사용할 수도 있다.

### 리턴값이 있는 함수

리턴값이 있는 함수는 변수에 대입할 수 있는 하나의 값을 만들어 낸다.

![sqrt](https://github.com/Idealm99/idealm99.github.io/assets/112872986/28e03538-3844-4239-b605-2e04f83d244a)

함수가 잡업을 끝내면 구문에 있는 함수 호출이 그 리턴값으로 대체된다.

즉 매게변수는 함수에 전달되는 정보이고, 리턴값은 함수가 돌려주는 값이다

실수를 c++에서는 double형으로 나타낸다 
```
    double sqrt(double);   //함수원형
    앞의 double은 sqrt() 함수가 double형의 값을 리턴한다는 뜻이고
    뒤의 double은 sqrt() 함수가 double형의 매개변수를 전달받는다는 뜻이다.

    double x;        // x를 double형 변수로 선언한다.
    x = sqrt(6.25);
   ````
 
### 변이 함수들

    double pow (double , double);   //2개의 매개변수를 가진 함수 원형
    int rand(void);                 // 매개변수가 없는 함수 원형
    myGuess = rand();               // 매개변수가 없는 함수 호출
    void bucks(double);             // 리턴값이 없는 함수 원형
    bucks(1.54);                    // 리턴값이 없는 함수 호출

### 사용자 정의 함수

    #include <iostream>
    void simon(int);
    int main() 
    {
        using namespace std;
        simon(3);
        return 0;
    }
    void simon( int n)
    {
       using namespace std;
       cout << "simon 왈 발가락을" << n << "번 두드려라." << endl;
    }

    출력물
    simon 왈 발가락을 3번 두드려라.

이러한 결과물이 된다 simon이라는 함수를 만들고 void simon( int n)에서 () 안에 입력받을 변수 타입을 정해주고
 main에서 함수를 호출하면 이렇게 simon함수 안에 있는 것들이 실행된다.

 만약 simple - simon(3); 이면 void형 함수이므로 이렇게 사용할 수 없다.
 
 ### 리턴값이 있는 사용자 정의 함수

 
# 3장 데이터 처리<a class="anchor" id="3"></a>

## 변수 이름

    * 변수 이름에는 영문자,숫자,밑줄 문자만을 사용할 수 있다.
    * 숫자를 변수 이름의 첫 문자로 사용할 수 없다.
    * 변수 이름에 대문자와 소문자는 구별된다
    * C++의 키워드는 변수 이름으로 사용할 수 없다
    * 두개의 밑줄 문자로 시작하는 이름이나 밑줄 문자와 대문자로 시작하는 이름은 그것을 사용하는 컴파일러와 리소스가
    하나의 밑줄은 컴파일러와 리소스가 전역 식별자로 사용
    * 변수 이름의 제한이 없으며 변수 이름에 쓰인 모든 문자들이 유효하다.

## 정수형 

정수는 2, 54 87 같이 소수부가 없는  수를 말한다. 그런데 컴퓨터의 메모리 용향에는 한계가 있으므로 길이가 제한된다.
양수값과 음수값 모두 나타낼 수 있으나 unsigned 데이터형은 양수값만 나타낼 수 있다.
기본 정수형 크기 순서로는

    char < short < int < long < long long 순이다.
    *short 16bit
    *int 32bit
    *long long 64bit more

    선언 방법

    *short score;
    *int score;
    *long score;

### 데이터 크기 알아내는 방법

1. sizeof 연산자 데이터형의 크기를 바이트 단위로 리턴한다
2. climits 헤더 파일 열어 보는 방법

climits에 정의되어 있는 기호 상수들

![climits](https://github.com/Idealm99/idealm99.github.io/assets/112872986/3d32c2af-3fa2-4be2-aba9-c439cab06e9a)

### 초기화 

초기화는 선언과 대입을 하나로 조합한다. 에로
```
    int n_int = INT_MAX;
    int uncle = 5; //uncle 5로 초기화
    int uncle(5);  // C++의 새로운 초기화 문법
```

## unsigned 형

C++ 의 unsigned 형은 부호가 없는 정수형입니다. 부호가 없는 정수는 양수만 저장할 수 있습니다. unsigned 형의 범위는 부호가 있는 정수형의 범위보다 큽니다. 예를 들어, unsigned int 의 범위는 0 ~ 4294967295 이고, int 의 범위는 -2147483648 ~ 2147483647 입니다.

unsigned 형을 사용하는 이유는 다음과 같습니다.

* 양수만 저장해야 할 때
* 부호가 있는 정수형보다 더 큰 범위의 정수를 저장해야 할 때
* 부호 오류를 방지해야 할 때

unsigned 형을 사용할 때는 다음과 같은 점에 유의해야 합니다.

* unsigned 형은 부호가 없는 정수형이기 때문에 음수를 저장할 수 없습니다.
* unsigned 형과 부호가 있는 정수형을 연산할 때는 부호가 있는 정수형을 unsigned 형으로 변환합니다.
* unsigned 형과 부호가 있는 정수형의 범위가 다르기 때문에 unsigned 형으로 변환할 때는 주의해야 합니다.

unsigned 만 있는 것은 unsigned int 를 줄여서 나타낸 것이다.

## C++가 상수의 데이터형을 결정하는 방법

1. 상수의 값을 기준으로 데이터형을 결정합니다.
2. 상수의 이름에 접미어를 붙여 데이터형을 지정할 수 있습니다.
3. 상수의 데이터형을 명시적으로 지정할 수 있습니다.

예를 들어, 상수의 값이 100이면 int형으로 결정됩니다. 상수의 이름에 접미어를 붙여 데이터형을 지정할 수도 있습니다. 예를 들어, `const int a = 100;`은 int형 상수 `a`를 선언합니다. 상수의 데이터형을 명시적으로 지정할 수도 있습니다. 예를 들어, `const int a = 100u;`은 unsigned int형 상수 `a`를 선언합니다.

C++ 의 const 는 변수나 함수를 상수로 선언하는 키워드입니다. const 로 선언된 변수는 그 값을 변경할 수 없으며, const 로 선언된 함수는 그 인자를 변경할 수 없습니다. const 는 C++ 의 오류 방지 기능 중 하나로, 프로그램의 안정성을 높이는 데 도움이 됩니다.

const 를 사용하는 방법은 다음과 같습니다.

* 변수 선언시 const 를 사용합니다.
```
const int a = 10;
```
* 함수 선언시 const 를 사용합니다.
```
void f(const int a) {
  // a 의 값을 변경할 수 없습니다.
}
```

const 를 사용하면 다음과 같은 이점이 있습니다.

* 프로그램의 안정성을 높일 수 있습니다.
* 코드를 이해하기 쉽게 만들 수 있습니다.
* 코드를 유지보수하기 쉽게 만들 수 있습니다.

const 를 사용하면 C++ 로 작성하는 프로그램의 품질을 향상시킬 수 있습니다.

### char 형 문자와 작은 정수

문자와 숫자를 저장하기 위한 형태이다.

char형은 문자들을 처리하는데 사용할 수도 있다.

예를 들어서 ASCII 에서 A는 65다

    char ch= 65;
    cout << ch

    출력물 = A
    

입력할 때 문자 A에 해당하는 코드인 65을 ch에 입력하면 숫자가 아닌 그에 해당하는 문자인 A가 나온다.
이것은 char가 바꾸는 것이 아닌 cout에서 변환하는 것이다.

cout.put(A);은 ASCII로 변환하지 않고 문자 그대로 나오게 한다.
```
    char alarm = '|a';
    cout << alarm << "틀렸습니다!|a|n";
    cout << "정답은|n 김소월의 |"진달래 꽃|"입니다!|n";
```

    *실행 결과*
    정답은
    김소월의 "진달래 꽃"입니다!

![이스케이프](https://github.com/Idealm99/idealm99.github.io/assets/112872986/12d4b318-0e96-4ff9-a916-49945f47a8db)

signed char , unsigned char

int 형과 달리 char 형은 signed 형이나 unsigned형으로 미리 정해져 있지 않다.
그러나 char 형이 어느 특별한 한 가지 행도만을 보여야 한다면 

signed char bar;

unsigned char bar;
로 나타내면 된다.

#### wchar_t, char16_t, char32_t

C++의 wchar_t, char16_t, char32_t는 모두 멀티바이트 문자를 저장하기 위한 데이터 타입입니다. wchar_t는 가장 일반적인 멀티바이트 문자 타입으로, UCS-2 코드 포맷을 사용합니다. char16_t는 UTF-16 코드 포맷을 사용하며, char32_t는 UTF-32 코드 포맷을 사용합니다.

wchar_t는 UCS-2 코드 포맷을 사용하기 때문에, UCS-2 코드 포맷에 해당하는 문자만 저장할 수 있습니다. char16_t는 UTF-16 코드 포맷을 사용하기 때문에, UTF-16 코드 포맷에 해당하는 문자만 저장할 수 있습니다. char32_t는 UTF-32 코드 포맷을 사용하기 때문에, UTF-32 코드 포맷에 해당하는 모든 문자를 저장할 수 있습니다.

wchar_t, char16_t, char32_t는 모두 문자열을 저장하기 위한 데이터 타입이므로, char 타입과 마찬가지로 문자열 연산을 수행할 수 있습니다. 예를 들어, wchar_t, char16_t, char32_t 타입의 문자열을 연결하거나, 문자열의 길이를 구하거나, 문자열을 비교하는 등의 연산을 수행할 수 있습니다.

wchar_t, char16_t, char32_t는 모두 char 타입보다 메모리 공간을 더 많이 차지합니다. 따라서, 문자열의 크기가 크지 않은 경우에는 char 타입을 사용하는 것이 더 효율적일 수 있습니다.

### bool형 

bool형은 true 또는 false 형으로 나오게 하는 데이터형인데 하나의 값만 가질 수 있다.

## const 제한

기호상수를 다르는 방법이고 const 키워드를 사용하여 변수를 선언하고 초기화하는 것이다.
예를 들어서 1년의 달 수를 기호 상수로 나타내고 싶다면 프로그램에 다음과 같은 행을 넣으면 된다.

    const int MONTHS = 12;

이후 MONTHS에 어떠한 변경을 할려고 해도 가능하지 않고 에러가 뜬다 . 3이라는 수를 4로 바꿀려고 하는 것과 같다.

그리고 선언할 때 초기화해야한다!!

## 부동 소수점수

### 부동 소수점 표

2.52e+8    // E 또는 e를 사용할 수 있으며 +는 생략할 수 있다

8.33F-4    // 지수는 음수일 수도 있다

7E5        // 7.0+05와 같다

-18. 32e13 // 앞에 +나 - 부호를 넣을 수 있다

1.69e12    // 2010년 브라질 공채 (브라질 통화 기준: reais)

5.98E24    // 킬로그램 단위로 지구의 질량

9.11e-31   // 킬로그램 단위로 전자의 질량.

### 부동 소수점형

              float , double  , long double
    최소 비트 : 32      48         80,96,128

### 부동 소수점형 상수

부동 소수점형 상수를 float 형으로 저장하고 싶으면 F,f 점미어로 
long double 형으로 저장하고 싶으면 L,l 점미어로 사용해라

    예
    1.234f
    
    1.234F
    
    1.234L
    
    1.234l l대신에 L을 사용해라

### 부동 소수점의 장단점

1. 정수와 정수 사이에 있는 값을 나타낼 수 있다.
2. 스케일을 사용하여 매우 큰 범위의 값을 나타낼 수 있다.
그러나 부동 소수점수 연산은 수치 연산 보조 프로새서 없는 컴퓨터에서 정수 연산보다 속도가 느리다.

```
    // fltadd.cpp -- float형에서의 정밀도 손실 문제
    #include <iostream>
    int main ()
   {
    using namespace std;
    float a = 2.34+22f;
    float b=a + 1.0f;
    cout << "a = " << a << endl;
    cout << "b - a = " << b - a << endl;
    return 0;
   }

  ``` 

프로 그램은 어떤 수에 1을 더한 후 원래의 수를 뺀다. 예상되는 결과는 1
이어야 한다. 그러나 실제로 그럴까? 다음은 우리가 사용한 시스템에서 
프로그램을 실행한 결과이다.

    a p 2.34e+022
    b - a = 0

이렇게 결과가 나온 이유는 2.34E+22가 소수점 위로 23개의 숫자를 가진 큰 수이기 때문에 발생한 것이다.

이 수에 1을 더하는 것은 23번째 숫자에 1을 더하는 것과 같다 

float형은 처음 6개의 숫자 또는 7개의 숫자까지만 나타낼 수 있으므로 23번째 숫자에 1을 더하는 것은
아무런 효과도 갖지 못한다.

## C++ 산술 연산자

    +, -, *, /, % 
    + : 두개의 피연산자를 더한다
    - : 두개의 피연산자를 뺀다
    * : 두개의 피 연산자를 곱한다
    / : 두개의 피 연산자를 나눈다
    % : 두개의 피 연산자를 나누고 나머지를 구한다.

### 연산 순서 : 우선순위와 결합 방향

(*,/,%) > +, - 같은 우선순위는 앞에 있는 연산자 먼저

### 나눗셈에 대한 보충

    정수 나s눗셈: 9/5 = 1
    부동 소수점수 나눗셈: 9.0/5.0 = 1.800000
    혼합 나눗셈: 9.0/5 = 1.800000
    double형 상수: 1e7/9.0 = 1111111.111111
    fioat형 상수: 1e7f/9.0f = 1111111.125000

### 데이터형 변환

C++에서 데이터형 변환은 변수나 값의 데이터형을 다른 데이터형으로 변환하는 과정을 의미합니다. 데이터형 변환은 때로는 필요한 연산을 수행하거나 변수를 다른 형식으로 표현해야 할 때 유용합니다. C++에서는 명시적(explicit) 변환과 암시적(implicit) 변환 두 가지 유형의 데이터형 변환을 지원합니다.

암시적 변환(묵시적 변환, Implicit Conversion):
암시적 변환은 컴파일러가 자동으로 수행하는 데이터형 변환이며, 컴파일러가 허용하는 변환 규칙을 따라 수행됩니다. 일반적으로 작은 크기의 데이터형에서 큰 크기의 데이터형으로의 변환이나 정밀도 손실이 없는 변환 등이 암시적으로 처리됩니다. 예를 들어, 정수에서 실수로의 변환, 작은 정수형에서 큰 정수형으로의 변환 등이 암시적 변환이 될 수 있습니다.


    int num1 = 10;
    double num2 = num1;  // 암시적 변환: int를 double로 변환
    
명시적 변환(명시적 형변환, Explicit Conversion):
명시적 변환은 프로그래머가 직접 지정하여 수행하는 데이터형 변환으로, 명시적으로 변환 연산자를 사용해야 합니다. 이러한 변환은 데이터의 손실이 발생하거나 특정 연산을 수행하기 위해 필요한 경우에 사용됩니다. C++에서는 C 스타일의 형변환과 C++ 스타일의 형변환(deprecated) 두 가지 방법으로 명시적 변환이 가능합니다.

C 스타일 형변환:
C 스타일의 형변환은 기존 C 언어에서 사용되던 형식으로, (타입) 형태로 표현됩니다.

    double num1 = 3.14;
    int num2 = (int)num1;  // 명시적 변환: double을 int로 변환
    
C++ 스타일 형변환 (deprecated):
C++에서는 C 스타일 형변환 대신, C++ 스타일의 형변환을 권장합니다. C++ 스타일 형변환은 다음 네 가지 형태로 사용될 수 있습니다.

static_cast<타입>(표현식): 일반적인 형변환에 사용되며, 컴파일 타임에 검사됩니다.
dynamic_cast<타입>(표현식): 클래스 계층 구조에서의 형변환에 사용되며, 실행 중에 타입을 검사합니다.
reinterpret_cast<타입>(표현식): 포인터 타입 사이의 형변환에 사용되며, 주소 값을 바꾸거나 포인터 크기를 변경하는 데 사용됩니다.
const_cast<타입>(표현식): const 한정자를 추가하거나 제거하기 위한 형변환에 사용됩니다.


    double num1 = 3.14;
    int num2 = static_cast<int>(num1);  // 명시적 변환: double을 int로 변환
    
#### 표현 방법

구식은 (int) 1.32
신식    int (1.32)

### auto 선언

초기화 선언시 테이터형을 쓰지 않고 auto를 사용할 수 있다.

    auto n =100;  //n은 정수
    auto n =100.2;  //n은 double
    auto n =10.3e12L;  //n은 long double

하지만 이것만 쓰는 것은 좋지 않다 왜냐하면.

0.0 대신에 0을 사용하는 경우 문제가 발생할 수 있다. (나중에 9장에서 자세하게 다룹니다.)

# 4장 복합형 데이터<a class="anchor" id="4"></a>

## 4.1 배열

배열은 데이터형이 같은 여러 개의 값을 연속적으로 저장할 수 있는 데이터구조이다.

배열 선언 구문에서 선언하는 3가지

1. 각 원소에 저장될 값의 데이터형
2. 배열의 이름
3. 배열 원소의 개수

배열을 개별적인 접근을 위해 인덱스( subscript, index)를 사용하여 배열 원소에 차레로 번호가 매겨진다.
배열 인데스는 항상 0부터 시작한다.

### 배열 초기화 규칙

1. 배열의 초기화는 배열을 정의한 곳에서만 사용할 수 있다.
2. 배열을 부분적으로 초기화하면 컴파일러가 나머지 원소들을 모두 0으로 설정한다(첫 번째 원소만 0으로 초기화하면 나머짇 0이된다)
3. ([]) 대괄호 안을 비워두면 초기화 값의 개수를 헤아려 배열 원소의 개수를 결정한다. ex) int a[]={1, 2};

### C++11 배열 초기화

c++11에서 몇 가지가 추가 되었다.

1. 배열을 초기화할 떄 = 부호를 사용하지 않아도 된다.
2. 중괄호 공백하여 모든 배열을 0으로 초기화할 수 있다.
3. 리스트 초기화시에 narrowing 을 방지할 수 있다.

## 4.2 문자열

문자열이란 메모리에 바이트 단위로 연속적으로 저장되어 있는 문자들을 말한다.

c++에서 두가지 방법으로 문자열을 처리한다.

1. C로부터 유래한 C스타일의 문자열 처리 방법

모든 문자열의 마지막 문자가 반드시 *널* 문자여야한다. 널 문자는 |0 러 쓰며 ASCII코드가 0인 문자이다 그것은 문자열의 끝에 표시한다.

예를 들어서

    char dog[3]= {'a', 'b' , 'c' };       // 문자열이 아니다
    char dog[3]= {'a', 'b' , 'c','|0' };  // 문자열이다.

그러나 이보다 좋은 방법이 있다

    char cat[10] = "Mr. Cheeps";    // |0을 저장한다.
    char cat[] = "Mr. Cheeps";      // 컴파일러가 알아서 처리한다.
    (") 로 묶인 문자열은 끝내기 널 문자를 암시적으로 가지고 있다.

char size = 'S'; 맞다

char size = "S" 데이터형 불일치

왜냐하면 "S"는 두개의 문자 S 와 |0 로 구성된 문자열을 나타낸다.

### 문자열 상수의 결합

문자열이 너무 길면 

    cout << "I love" "you"
    cout << "I love you"
    cout << "I lo" "ve you"
    모두 같게 출력된다.

### 배열에 문자열 허용

1. 배열을 문자열 상수로 초기화하는 방법
2. 키보드 입력이나 파일 입력을 배열에 저장하는 방법

    1. char name1[10] = "C++owboy";
    2. char name2[10];
       cin >> name2
    문자열에 칸에서 입력되지 않은 곳은 |0으로 채워진다 예로 C + + o w b o y |0 |0 이런 식로

### 한 번에 한 행의 문자열 입력 읽기

#### getline()

getline()함수는 엔터키에 의해 전달되는 개행 문자를 입력의 끝으로 간주하여 한 행 전체를 읽는다
cin.getline()함수 호츨로 사용함으로써 이 메서드를 호출할 수 있다.


cin.getline( 배열 이름, 문자들의 한계) 
한계가 20이면 19개까지 문자들을 입력받을 수 있다 나머지 한 자리는 널 문자를 위해 예비해 두는 것이다.

     ex)cin.getline( name, 20 );    //이 구문은 한 행 전체를 읽어 name 배열에 저장한다.
     이때 그 행의 문자들의 개수는 최대 19개이다.

#### get() 을 이용한 행 단위 입력

개행 문자를 읽어서 버리지 않고 입력 큐에 그대로 남겨둔다.

    cin.get(name, size);
    cin.get(name2, size);   //문제 발생
    * 첫 번째 호출이 입력 큐에 개행 문자를 그대로 남겨 두기 대문에 두 번째 호출은 
    그 개행 문자를 첫 문자로 만나게 된다.
    그래서  get()은 읽을 것도 없이 곧 바로 행에 끝에 도달했다고 결론을 내린다.

다행히 get()의 한 변종으로부터 도움을 받을 수 있다

    cin.get(name, size);    // 첫 번째 행을 읽는다.
    cin.get();              // 개행 문자를 읽는다.
    cin.get(name2, size);   // 두 번째 행을 읽는다.
    
cin.get();을 사용하면 개행 문자를 읽어서 처리하고 다음 행의 입력으로 넘어가게 할 수 있다.

또 다른 방법은 두 개의 클래스 맴버 함수를 결합하여 사용하는 것이다.

    cin.get(name, size).get();   // 맴버 함수들을 결합한다

    cin.getline(name1, size).cin.getline(name2, size);    // 맴버 함수들을 결합한다.
    (cin.getline()을 두번 호출하는 것과 같다) 
    
getline 대신에 get을 사용하는 이유
1. 구식 c++ 에는 getline이 없기 때문에
2. get 이 사용자를 다소 신중하게 만들기 때문에
   예를 들어서 배열에 한 행을 저장하기 위해 get을 사용하면 get이 배열의 수납 범위를 벗어나지 않는
   전체 행을 읽어들였는지 어떻게 알까 그 다음 입력 문자를 살펴보면 된다.
   즉 *getline은 사용하기 좀 더 편하고 get은 에러 체킹이 좀 더 쉽다*

### 문자열과 수치의 혼합 입력

```
#include <iostream>

using namespace std;

int main()
{
    cout<<"원룸 언제부터 살았어?\n";
    int year;
    std::cin >> year;
    cout << "사는 도시는 어디야? \n";
    char address[80];
    cin.getline(address, 80);
    cout << "입주년도" << year << endl;
    cout << "도시는" << address << endl;
    cout << "등록 끝 \n";


    return 0;
}
```
출력물

    원룸 언제부터 살았어?
    2022
    사는 도시는 어디야? 
    입주년도2022
    도시는
    등록 끝 

```
#include <iostream>

using namespace std;

int main()
{
    cout<<"원룸 언제부터 살았어?\n";
    int year;
    (std::cin >> year).get();
    cout << "사는 도시는 어디야? \n";
    char address[80];
    cin.getline(address, 80);
    cout << "입주년도" << year << endl;
    cout << "도시는" << address << endl;
    cout << "등록 끝 \n";


    return 0;
}
```
출력물

    원룸 언제부터 살았어?
    2022
    사는 도시는 어디야? 
    안성
    입주년도2022
    도시는안성
    등록 끝 


위에 코드에서 보이듯이 std::cin >> year; 이 코드를 입력할 기회를 주지 않는다

cin이 입주 연도를 읽어들이고 Enter 키가 만들어 내는 개행 문자를 입력 큐에 남겨 두기 때문에
발생하는 문제이다.

cin.getline()은 입력 큐에 남겨진 개행 문자를 빈 행으로 읽어들이고 address 배열에

널 문자열을 대입한다. 이 문제를 해결하는 방법은 주소를 읽기 전에 개행 문자를 읽어

허공에다 버리는 것이다. 그래서 아래 코드에서 처럼 get()을 사용하여 문제를 해결할 수 있다.

* C++프로그램은 문자열을 처리하기 위해 배열 대신에 포인터를 더 많이 사용한다

## 4.3  String 클래스

문자열을 저장하는 데 문자 배영을 사용하는 대신에 string형 변수(객체)를 사용할 수 있다.

string 클래스를 사용하려면 프로그램에 string 헤더 파일을 포함시켜야 한다.

    #include <string>    // string 클래스 사용하기 위해

string 클래스는 std 이름 공간에 속해 있으므로 using 지시자를 사용하거나 std::string를
사용하여 그 클래스를 참조해 주어야 한다.

```
#include <iostream>
#include <string>               // string 클래스를 사용한다
int main()
{
    using namespace std;
    char charr1[20];            // create an empty array
    char charr2[20] = "jaguar"; // create an initialized array
    string str1;                // create an empty string object
    string str2 = "panther";    // create an initialized string

    cout << "Enter a kind of feline: ";
    cin >> charr1;
    cout << "Enter another kind of feline: ";
    cin >> str1;                // use cin for input
    cout << "Here are some felines:\n";
    cout << charr1 << " " << charr2 << " "
         << str1 << " " << str2 // use cout for output
         << endl;
    cout << "The third letter in " << charr2 << " is "
         << charr2[2] << endl;
    cout << "The third letter in " << str2 << " is "
         << str2[2] << endl;    // use array notation
    // cin.get();
	// cin.get();

    return 0; 
}

```     
실행 결과물 

    Enter a kind of feline: ocelot
    Enter another kind of feline: tiger
    Here are some felines:
    ocelot jaguar tiger panther
    The third letter in jaguar is g
    third letter in panther is n

-위 코드를 통해서 배울 내용-

* C스타일 문자열로 string 객체를 초기화할 수 있다.
* cin을 사용하여 string 객체에 키보드 입력을 저장할 수 있다
* cout을 사용하여 string 객체에 키보드 입력을 저장할 수 있다.
* 배열 표기를 사용하여 string 객체에 저장되어 있는 개별적인 문자들에 접근할 수 있다.

*string 객체와 문자 배열의 가장 큰 차이점은 string 객체를 배열이 아니라 단순한 변수로 선언하는 것이다.*

### C++ 문자열 초기화

    char first [] = {"이건 좀 불편한데"};
    string second = {" 그래 이거지 이거야"};

### 대입, 결합, 추가

string 클래스는 배열보다 조작이 간단하다.
하나의 배열을 다른 배열에 간단하게 대입할 수 없지만 하나의 string 객체를 다른 string 객체에 
간단하게 대입할 수 있다.

```
char chaarr1[20];    // 빈 배열을 생성한다
char chaarr2[20] = "이렇게";// 초기화된 배열을 생성한다
string str1;                //빈 스트링 객체를 생성한다
string str="이렇게";         //초기화된 스트링 객체를 생성한다
charr1 = charr2;    //틀리다 배열 대입 X
srt1 = str2;        //맞다 객체 대입 O
```

```
str3= str1 + str2;
//위 코드와
strcpy(charr3 , charr1);
strcpy(charr3 , charr2);
// 위에 코드들은 같은 의미를 갖는데 char 배열을 쓰냐 string객체를 사용하냐에 따라 표현 방법이 다르다.

char chaarr2[5] = "이렇게"
strcpy(charr2 ,"이것을 추가한다"); // 메모리 문제 발생

// 길이를 구하는 코드는
int len1 = str1.size();    // str1 의 길이를구한다
int len2 = strlen(charr1); //charr의 길이를 구한다.
```
### string 클래스의 입출력
```
// strtype4.cpp -- line input
#include <iostream>
#include <string>               // make string class available
#include <cstring>              // C-style string library
int main()
{
    using namespace std;
    char charr[20]; 
    string str;

    cout << "Length of string in charr before input: " 
         << strlen(charr) << endl;
    cout << "Length of string in str before input: "
         << str.size() << endl;
    cout << "Enter a line of text:\n";
    cin.getline(charr, 20);     // indicate maximum length
    cout << "You entered: " << charr << endl;
    cout << "Enter another line of text:\n";
    getline(cin, str);          // cin now an argument; no length specifier
    cout << "You entered: " << str << endl;
    cout << "Length of string in charr after input: " 
         << strlen(charr) << endl;
    cout << "Length of string in str after input: "
         << str.size() << endl;
    // cin.get();

    return 0; 
}
```
출력물

    Length of string in charr before input: 0
    Length of string in str before input: 0
    Enter a line of text:
    abcde
    You entered: abcde
    Enter another line of text:
    abcdef
    You entered: abcdef
    Length of string in charr after input: 6
    Length of string in str after input: 6

1. 초기화되지 않은 배열의 내용은 저의되지 않는다
2. strlen() 함수는 배열의 첫 번째 원소에서 출발하여 널 문자에 도달할 때가지 바이트들을 카운트한다.

여기에서 책과 내용이 다른 점은 Length of string in charr before input: 0 이 부분이다

책에서는 2번의 내용으로 27이 나오지만 코드를 돌려본 결과 0으로 나온다.

```
cin >> str; // 한 단어를 읽어 str에 넣는다
cin >> x ;  // 한 값을 읽어 기본 데이터형에 넣는다
```

## 구조체

하나의 배열에 절반은 int형 절반은 char 형으로 만들 수 없다

이 문제를 해결하기 위해서 나온 것이 *구조체*이다.

그리고 구조체는 사용자가 정의할 수 있는 데이터 형이다.

구조체는 2 단계를 거쳐 생성된다.
1. 구조체 서술을 정의하는 단계
   -구조체 안에 저장할 여러 가지 데이터형들을 서술하고 이름을 정한다
2. 구조체 서술에 따라 구조체 데이터 객체를 생성
   
```
struct A  //구조체 선언
{
char name[20];
float volume;
double price;
};
```
여기서 struct는 이 코드가 구조체 서술을 정의하고 있다는 것을 나타낸다.

태그라고도 부르는 식별자 A는  새로 만들어지는 데이터형의 이름으로 사용된다.

이 리스트에는 배열이나 다른 구조체를 포함한 어떠한 종류의 데이터형도 넣을 수 있다.

그리고 마지막에 {} 괄호를 닫을 때 세미콜론(;) 을 붙여야한다.

### 프로그램에 구조체 사용하기

예시 코드

```
// structur.cpp -- a simple structure
#include <iostream>
struct a   // structure declaration
{
    char name[20];
    float volume;
    double price;
};

int main()
{
    using namespace std;
    a guest =
    {
        "Glorious Gloria",  // name value
        1.88,               // volume value
        29.99               // price value
    };  // guest is a structure variable of type inflatable
// It's initialized to the indicated values
    a pal =
    {
        "Audacious Arthur",
        3.12,
        32.99
    };  // pal is a second variable of type inflatable
// NOTE: some implementations require using
// static inflatable guest =

    cout << "Expand your guest list with " << guest.name;
    cout << " and " << pal.name << "!\n";
// pal.name is the name member of the pal variable
    cout << "You can have both for $";
    cout << guest.price + pal.price << "!\n";
    // cin.get();
    return 0; 
}
```
구조체 선언 위치는 두가지가 있다 
1. main() 함수의 안에 중괄호
2. main() 함수 밖에 선언을 두는 것을 외부 선언이라 한다
   여러 개의 함수로 이루어지는 프로그램에서는 이것이 커다란 차이가 날 수 있다.
   외부 선언은 선언 이후에 나오는 모든 함수들이 사용할 수 있으나 내부 선언은 그 선언이
   내부에서만 사용할 수 있다. 그래서 외부 구조체 선언을 장려한다.

```
    a guest =         // = 는 생략할 수 있음
    {
        "Glorious Gloria",  // name value
        1.88,               // volume value
        29.99               // price value
    }; 
```

geust.name[0]= G 이다 하지만 배열이 아니라 구조체이기 때문에 geust[0]은 아무 의미가 없다.

### C++11의 구조체 초기화
```
a guest { }; 
```
결국 narrowung은 허용되지 않는다.

### 구조체가 string 클래스 맴버를 사용할 수 있을까?

C++에서 구조체가 string 클래스 멤버를 사용할 수 있습니다. 예를 들어 다음과 같이 구조체에 string 클래스 멤버를 추가할 수 있습니다.

```
struct MyStruct {
  std::string name;
};
```

이제 MyStruct 구조체 인스턴스를 생성하고 string 클래스 멤버에 문자열을 할당할 수 있습니다. 예를 들어 다음과 같습니다.

```
MyStruct my_struct;
my_struct.name = "John Doe";
```

마지막으로 MyStruct 구조체의 string 클래스 멤버에 저장된 문자열을 출력할 수 있습니다. 예를 들어 다음과 같습니다.

```
std::cout << my_struct.name;
```

이 코드는 다음과 같은 출력을 생성합니다.

```
John Doe
```
### 구조체의 기타 특성

```
#include <iostream>
struct inflatable
{
    char name[20];
    float volume;
    double price;
};
int main()
{
    using namespace std;
    inflatable bouquet =
    {
        "sunflowers",
        0.20,
        12.49
    };
    inflatable choice;
    cout << "bouquet: " << bouquet.name << " for $";
    cout << bouquet.price << endl;

    choice = bouquet;  // 한 구조체를 다른 구조체에 대입
    cout << "choice: " << choice.name << " for $";
    cout << choice.price << endl;
    // cin.get();
    return 0; 
}
```
위에 코드에서 있는 것 처럼 bouquet 구조체의 맴버 값들이 choice 구조체의 맴버들에 각각 대입되었다.

```
struct inflatable
{
    char name[20];
    float volume;
    double price;
}choice,bouquet; //이렇게 바로 2개의 변수를 만들 수 있다. 
```
변수를 생성할 때 초기화를 할 수 있지만 이해하기 어려우니 잘 사용하지 않는다.

### 구조체의 배열

```
a gift[100];       // a형 구조체 100개의 배열
cin >> gift[0].volume;  // 첫 번째 구조체의 volume 맴버에 입력
cout << gift[99].volume; << endl; //마지막 구조체의 volume 맴버를 출력
```

gifr 자체는 구조체가 아니라 배열이므로 gifr.volume과 같은 표현은 구조체의 배열을 초기화하는 방법은 
구조체 초기화 규칙과 배열 초기화 규칙을 하나로 결합하는 것이다 

즉 배열 원소가 구조체이므로 배열 원소의 각 값을 구조체 초기화 형식으로 나타낸다

```
a gift[2] =              // 구조체의 배열을 초기화
{
{"bam", 0.5, 21.99},     // 첫 번째 배열 원소인 구조체
{"nom", 0.3, 21.9}       // 두 번째 배열 원소인 구조체
};
```

### 구조체 안의 비트 필드

필드형은 정수형이나 열거자여야한다.

```
struct torgle_register{
unsigned int sn : 4; // sn 값 4비트
unsigned int  : 4;   // t사용하지 않음 4비트
bool goodIn : 1;     // 유효한 입력 1비트
bool goodTrogle : 1; // 토글에 성공 1비트
};

```
----

## 4.5 공용체

공용체는 서로 다른 데이터형을 한 번에 한 가지만 보관할 수 있는 데이터 형식이다.

즉 구조체는 모든 데이터 형 vs 공용체는 한 데이터 형만

구문은 구조체와 같지만 의미가 조금 다르다.

```
union one
{
 int int_val;
 long long_val;
 double double_val;
};

```
one 변수는 int 형이나 double 형을 보관할 수 있지만  어느 한 시점에 어느 한 가지만 보관할 수 있다.

```
oe pail;
pail.int_val = 15;    //int 형을 저장
cout << pail.int_val;
pail.double_val = 1.38;  //double 형을 저장 int형 값은 소실
cout << pail.double_val;

```

가장 큰 멤버를 보관할 수 있을 만큼의 공간이 필요하다 

따라서 공용체의 크기는 가장 큰 멤버의 크기이다.

여러 가지 데이터형을 사용할 수는 있지만 이들을 동시에 사용할 수 없을 때 공용체를 사용하면 메모리를 절약할 수 있다.


## 4.6 열거체

enum(열거체) 기능은 const 를 사용하여 기호 상수를 만드는 것에 대한 또 다른 방편을 제공한다.

enum을 사용하는 구문은 구조체 구문과 비슷하다 예를 들어

```
enum spectrum ( a, b, c, d, e, f, g};

```

이 구문은 두 가지 일을 수행한다

1. spectrum 을 새로운 데이터형의 이름으로 만든다. (열거체체)
2. a, b, c ... 등을 0에서 7까지의 정수 값을 각각 나타내는 기호 상수로 만든다.  이 상수들을 *열거자라* 부른다

첫 번째 열거자는 0 두번째는 1 

```
spectrum band;    // band는 spectrum형의 변수
band = b;         // 맞다 b 는 열거자다
band= 200;        // 틀리다 2000은 열거자가 아니다
band = c + d;     // 틀리다
int color = c;    // 맞다 spectrum 형이 int 형으로 승급된다.
band = 3;         // 틸리다 int 형이 spectrum형으로 변환되지 않는다.
color = 3 + d;    // 맞다 d가 int 형으로 변환된다.
band = spectrum(3);// 3을 spectrum형으로 데이터형 변환
band = spectrum(300003);// 미확정
```
열거자들에 대해 + 연산자는 정의되어 있지 않다

### 4.6.1 열거자 값의 설정

대입 연산자를 사용하여 열거자의 값을 명시적으로 지정할 수 있다.
```
enum bit {a= 1, b =2, c = 3, d = 4};   //대입되는 값들은 정수여야한다. long 형도 가능
enum bit {a= 1, b , c , d = 4};        //일부 열거자에만 명시적으로 값을 대입할 수 있다
```

### 4.6.2 열거체의 값 범위

```
enum Day {
  Sunday=2,
  Monday=4,
  Tuesday=8,
};
Day today;
today = Day(6); //맞다 6이 Day 범위 안에 들어왔다 
```
상한 = (열거자 값 중 최대값)< (2^2 or 4^2 중에 큰 값 )-1

## 4.7 포인터와 메모리 해제

포인터는 값 자체가아니라 값의 주소를 저장하는 변수이다.

주소 연산자(&) 를 변수 앞에 붙이면 그 벼수의 주소를 알 수 있다. 주소는 16진수로 나타낸다.

포인터라는 특별한 데이터형의 변수에 어떤 주소를 저장한다 
- 즉 포인터의 이름이 주소를 나타낸다.

간접값 연산자 또는 간접 참조 연산자라고 부르는 *를 포인터 이름 앞에 붙이면
그 주소애 저장되어 있는 값이 된다.

예를 들어서

    *a

1. *a는 그 주소에 저장되어 있는 값을 나타낸다.
2. *a 는 보통의 int형 변수와 동등하게 취급된다.

```
int A = 6;
int *B ;

B=&A;
```
결과는

    A = 6 *B = 6
    &A =0012FF7C B = 0012FF7C
    *B = *B+1
    *B = 7 

### 4.7.1 포인터의 선언과 초기화

char 과 double 은 바이트 수가 다르고 저장 형식이 다르다 그로므로 포인터를 선언할 때에는 그 포인터가 지시하는 데이터형이 무엇인지 서술해야한다.

예를 들면 

    int * P_u;
    
-* P_u는 int형이라는 것을 나타낸다. P_u는 포인터임에 틀림없다
  
즉 P_u 의 데이터형은 int형을 지시하는 포인터 간단히 *int 형이다.

다시 말해서 P_u는 포인터(주소)이고 * P_u는 포인터가 아니라 int형 변수이다.

C++프로그래머들은 int* P_u; 과 같은 형시으로 사용한다.

    int* P1 , P2;

P1 은 포인터이고 P2는 int형 현수로 생성한다
둘 다 포인터로 만들고 싶으면 각각 * 를 붙여야한다.

tax ptr는 double형을 지시하는 포인
터(혹은 double *형)이고, str는 char형을 지시하는 포인터(char *형)이디
이들은 둘 다 포인터이지만 서로 다른 데이터형을 지시한다. 배열과 마찬가지로, 포
인터도 다른 데이터형을 기초로 하여 만들어진다.

tax _ ptr와 st.
변수 자체의 크기는 같다.  

char형의 주소와 double형의 주소
는 크기가 같다. 그러므로 특정 주소의 크기나 값만 가지고는 그 주소에 저장되
있는 변수의 크기나 총류를 알 수가 없다. 일반적으로 컴퓨터 시스템에 따라서 2비
이트나 4바이트로 주소를 나타낸다

선언 구문을 사용하여 포인터를 초기화할 수 있다. 이러한 경우에, 포인터에 의해
지시되는 값이 아니라 포인터가 초기화된다. 즉, 다음과 같은 구문은

    int higgens e 5;
    int * pt = &higgens;
    
포인터에 의해 지시되는 값인 *pt가 초기화되는 것이 아니라, 포인터인 pt가
higgens 값으로 초기화된다.

### 4.7.2 포인터의 위험


