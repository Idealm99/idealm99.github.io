![sqrt](https://github.com/Idealm99/idealm99.github.io/assets/112872986/a36e3cb5-ec3e-4fbf-832c-5a09a06738f6)<a class="anchor" id="0"></a>
# **C++**
**1차 보고서**
<a class="anchor" id="0.1"></a>

# **목차**


[1. c++ 첫걸음](#1)

[2. c++ 시작하기](#2)

[3. 데이터 처리](#3)

[4. 복합 데이터형](#4)

[5. 루프와 관계 표현식](#5)

---

# c++ 첫걸음<a class="anchor" id="1"></a>

## 1.1 c++ 사용하는 이유

    1.효율적이며,크기가 작고 실행 속도가 빠르며 이식성이 뛰어난 c를 그대로 물려받았다 
    2. 객체지향을 지원한다.
    3. 일반화 프로그래밍 추가

## 1.2 객체 지향 프로그래밍

    구조적 프로그래밍 철학이 프로그램의 간결성, 신뢰성 유지 보수의 용이성에 많은 향상을 가져왔지만 
    규모가 큰 프로그래밍은 여전히 어렵다. 
    이 문제를 해결하기 위해서 객체 지향 프로그래밍 철학이 등장했다. 
    객체지향 프로그래밍은 데이터를 강조한다. 또한 언어 자체를 해결해야 할 문제에 맞춘다.
    즉 해결해야 할 문제의 특성에 맞게 데이터형 자체를 설계하는데
    c++ 에서는 class 가 그와 같은 목적으로 설계되는 새로운 데이터형이다. 
    객체를 정확하게 서술하는 클래스를 먼저 설계 해야한다. 
    저수준의 클래스를 먼저 설계한 후에 고수준의 프로그램 설계를 하는데 이를 상향식 프로그래밍이라고 한다.

## 1.3 일반화 프로그래밍

 일반화 프로그래밍과 oop는 소스코드를 재활용하고 포괄 개념의 추상화 기술을 서로 공유한다. 

## 프로그래밍 절차

![절차](https://github.com/Idealm99/idealm99.github.io/assets/112872986/2d8f4946-c248-4cc3-80cf-0da3fd0dca77)

## 소스 코드의 파일 이름 구성 요소

    spiffy.ccp 

    spiffy는 기본 파일 이름 ccp는 확장자이다.

### 소스코드의 확장자 종류

![KakaoTalk_20230705_144418983](https://github.com/Idealm99/idealm99.github.io/assets/112872986/f367c924-83a8-4784-82e6-5ec6eb243a01)

## 컴파일러

   Unix는 CC 대문자임

# c++ 시작하기<a class="anchor" id="2"></a>

## main() 함수 

     int main()
     {
          구문들
          return 0;
     }
    
기본적으로 이러한 형태를 가지고 있다.
c++에서는 모든 구문이 끝날 때 세미콜론(;)을 붙여야한다.
그리고 main() 함수의 끝에 있는 구문은 return 구문이다. 이것은 함수를 종료하는 역활을 한다.

    int main 이 부분을 함수 이름 (인자리스트, 매개변수 리스트 ) 괄호 안의 이름들이다.

    int main(void) 괄호 안에 void가 있는것은 그 함수가 다른 함수로부터 어떠한 정보도
    전달받지 않는다는 것을 명시적으로 밝히는 것이다.
    // 괄호 안을 비워두는 것은 괄호 안에 void가 있는 것과 같다
    
    주석은 // 를 붙이면 된다 이것은 컴파일러가 읽지 않는다.

## c++ 전처리기와 iostream 파일

     #include <iostream>    // 전처리 지시자
     이 지시자는 전처리기에게 iostream 파일의 내용을 프로그램에 추가하라고 지시한다.

그렇다면 왜 iostream 파일의 내용을 프로그램에 추가할까?

     그 이유는 프로그램 바깥 세상이 정보를 주고받을 수 있도록 하기 위해서다.
     count을 사용하려면 이러한 정의가 필요하다
     **cout은 printf와 비슷한 것이다**

## 이름 공간

다음과 같은 이름 공간 지시자를 사용한다. 그러면 iostream.h 대신에 iostream을 사용할 수 있게 해준다.

     using namespace std;
     
이것을 using 지시자라 한다.
그리고 위에 코드를 작성하면 

    std::cout << " 이렇게 using 지시자를 생략하고 작성할 수 있다.";
    std::cout << std::endl;

## cout 을 이용한 출력

cout << (문자열,수,문자); 에서 << 는 (문자열,수,문자)를 cout에 전달한다는 것을 뜻한다.

새로운 행으로 시작하는 방법은
    *조정자 endl은 새로운 행이 시작된다는 코드이다.
    *다른 방법으로는 cout << " 다음 행으로 |n"; |n 이 있다.

### cout의 새로운 사용법

    int carrots = 25;
    cout << carrots;

위 코드는 crrots라는 단어를 출력하지 않고 변수 carrots에 현재 저장되어 있는 값인 정수 25를 출력한다

    1. cout은 carrots 를 정수 25로 대체한다
    2. 정수 25를 적당한 출력 문자 '2' '5'로 변환한다.
    
이처럼 cout는 문자열뿐만 아니라 정수도 출력할 수 있다. cout은 carrots가 변환할 필요가 있는 정수라는 사실을 알고 있다

    
## c++ 소스코드 모양

    #include <iostream>
        int
    main
    () {   using
         namespace
             std;  cout
                 <<
      "이게 가능하다고?"
      ;   cout <<
      endl; erturn 0;}

이렇게 작성하는 것도 가능하다.

    int ma in()       // 이름 안에 빈칸이 있어서 틀리다
    re
    turn 0;           // 키워드 안에 캐리지 리턴이 있어서
    cout << "Behold the Beans
    of Beauty!";      //문자열 안에 캐리지 리턴이 있어서 틀리다

## cin을 이용한 입력 

    cin >> carrots; 
    
 이 코드로 cin에 있는 값을 carrots 쪽으로 흐른다는 것을 보여주는 코드다
 
 cin은 키보드로 넣은 일련의 문자들인 입력을 그것을 저장할 변수가 받아들이는 형태로 바꾼다.

## cout에 의한 출력의 결합

iostream 파일에는 << 연산자가 여러 개의 출력을 하나로 결합(연결)
있도록 정의되어 있다

    cout << "이제 당근은 모두 " << carrots << "개이다." << endl;

이것은 문자열 출력과 정수 출력을 하나의 구문으로 결함한다. 이것의 실행 결
다음과 같은 세 행의 코드가 만들어 내는 결과와 동일하다.

    cout << "이제 당근은 모두"; 
    cout << carrots;
    cout << "개이다.";
    cout << endl;

또한 독자가 cout 을 사용하리는 권고를 받아들이기로 했다면, 하나로 결합된 .
구문을 다음과 같이 네 행에 결쳐 작성할 수도 있다.

    cout << "이제 당근은 모두"
    << carrots
    << "개이다."
    << endl; 
  

## 함수

C++에는 함수의 유형이 2가지가 있다.

    1. 리턴값이 있는 것과 리턴값이 없는 것
    2. 표준 함수 라이브러리에 있는 함수를 사용할 수도 있고 사용자가 직접 만들어 사용할 수도 있다.

### 리턴값이 있는 함수

리턴값이 있는 함수는 변수에 대입할 수 있는 하나의 값을 만들어 낸다.

![sqrt](https://github.com/Idealm99/idealm99.github.io/assets/112872986/28e03538-3844-4239-b605-2e04f83d244a)

함수가 잡업을 끝내면 구문에 있는 함수 호출이 그 리턴값으로 대체된다.

즉 매게변수는 함수에 전달되는 정보이고, 리턴값은 함수가 돌려주는 값이다

실수를 c++에서는 double형으로 나타낸다 

    double sqrt(double);   //함수원형
    앞의 double은 sqrt() 함수가 double형의 값을 리턴한다는 뜻이고
    뒤의 double은 sqrt() 함수가 double형의 매개변수를 전달받는다는 뜻이다.

    double x;        // x를 double형 변수로 선언한다.
    x = sqrt(6.25);
    
### 변이 함수들

    double pow (double , double);   //2개의 매개변수를 가진 함수 원형
    int rand(void);                 // 매개변수가 없는 함수 원형
    myGuess = rand();               // 매개변수가 없는 함수 호출
    void bucks(double);             // 리턴값이 없는 함수 원형
    bucks(1.54);                    // 리턴값이 없는 함수 호출

### 사용자 정의 함수




 
