<a class="anchor" id="0"></a>
# **C++**
**1차 보고서**
<a class="anchor" id="0.1"></a>

# **목차**


[1. c++ 첫걸음](#1)

[2. c++ 시작하기](#2)

[3. 데이터 처리](#3)

[4. 복합 데이터형](#4)

[5. 루프와 관계 표현식](#5)

---

# c++ 첫걸음<a class="anchor" id="1"></a>

## 1.1 c++ 사용하는 이유

    1.효율적이며,크기가 작고 실행 속도가 빠르며 이식성이 뛰어난 c를 그대로 물려받았다 
    2. 객체지향을 지원한다.
    3. 일반화 프로그래밍 추가

## 1.2 객체 지향 프로그래밍

    구조적 프로그래밍 철학이 프로그램의 간결성, 신뢰성 유지 보수의 용이성에 많은 향상을 가져왔지만 
    규모가 큰 프로그래밍은 여전히 어렵다. 
    이 문제를 해결하기 위해서 객체 지향 프로그래밍 철학이 등장했다. 
    객체지향 프로그래밍은 데이터를 강조한다. 또한 언어 자체를 해결해야 할 문제에 맞춘다.
    즉 해결해야 할 문제의 특성에 맞게 데이터형 자체를 설계하는데
    c++ 에서는 class 가 그와 같은 목적으로 설계되는 새로운 데이터형이다. 
    객체를 정확하게 서술하는 클래스를 먼저 설계 해야한다. 
    저수준의 클래스를 먼저 설계한 후에 고수준의 프로그램 설계를 하는데 이를 상향식 프로그래밍이라고 한다.

## 1.3 일반화 프로그래밍

 일반화 프로그래밍과 oop는 소스코드를 재활용하고 포괄 개념의 추상화 기술을 서로 공유한다. 

## 프로그래밍 절차

![절차](https://github.com/Idealm99/idealm99.github.io/assets/112872986/2d8f4946-c248-4cc3-80cf-0da3fd0dca77)

## 소스 코드의 파일 이름 구성 요소

    spiffy.ccp 

    spiffy는 기본 파일 이름 ccp는 확장자이다.

### 소스코드의 확장자 종류

![KakaoTalk_20230705_144418983](https://github.com/Idealm99/idealm99.github.io/assets/112872986/f367c924-83a8-4784-82e6-5ec6eb243a01)

## 컴파일러

   Unix는 CC 대문자임

# c++ 시작하기<a class="anchor" id="2"></a>

## main() 함수 

     int main()
     {
          구문들
          return 0;
     }
    
기본적으로 이러한 형태를 가지고 있다.
c++에서는 모든 구문이 끝날 때 세미콜론(;)을 붙여야한다.
그리고 main() 함수의 끝에 있는 구문은 return 구문이다. 이것은 함수를 종료하는 역활을 한다.

    int main 이 부분을 함수 이름 (인자리스트, 매개변수 리스트 ) 괄호 안의 이름들이다.

    int main(void) 괄호 안에 void가 있는것은 그 함수가 다른 함수로부터 어떠한 정보도
    전달받지 않는다는 것을 명시적으로 밝히는 것이다.
    // 괄호 안을 비워두는 것은 괄호 안에 void가 있는 것과 같다
    
    주석은 // 를 붙이면 된다 이것은 컴파일러가 읽지 않는다.

## c++ 전처리기와 iostream 파일

     #include <iostream>    // 전처리 지시자
     이 지시자는 전처리기에게 iostream 파일의 내용을 프로그램에 추가하라고 지시한다.

그렇다면 왜 iostream 파일의 내용을 프로그램에 추가할까?

     그 이유는 프로그램 바깥 세상이 정보를 주고받을 수 있도록 하기 위해서다.
     count을 사용하려면 이러한 정의가 필요하다
     **cout은 printf와 비슷한 것이다**

## 이름 공간

다음과 같은 이름 공간 지시자를 사용한다. 그러면 iostream.h 대신에 iostream을 사용할 수 있게 해준다.

     using namespace std;
     
이것을 using 지시자라 한다.
그리고 위에 코드를 작성하면 

    std::cout << " 이렇게 using 지시자를 생략하고 작성할 수 있다.";
    std::cout << std::endl;

## cout 을 이용한 출력

cout << (문자열,수,문자); 에서 << 는 (문자열,수,문자)를 cout에 전달한다는 것을 뜻한다.

새로운 행으로 시작하는 방법은
    *조정자 endl은 새로운 행이 시작된다는 코드이다.
    *다른 방법으로는 cout << " 다음 행으로 |n"; |n 이 있다.

### cout의 새로운 사용법

    int carrots = 25;
    cout << carrots;

위 코드는 crrots라는 단어를 출력하지 않고 변수 carrots에 현재 저장되어 있는 값인 정수 25를 출력한다

    1. cout은 carrots 를 정수 25로 대체한다
    2. 정수 25를 적당한 출력 문자 '2' '5'로 변환한다.
    
이처럼 cout는 문자열뿐만 아니라 정수도 출력할 수 있다. cout은 carrots가 변환할 필요가 있는 정수라는 사실을 알고 있다

    
## c++ 소스코드 모양

    #include <iostream>
        int
    main
    () {   using
         namespace
             std;  cout
                 <<
      "이게 가능하다고?"
      ;   cout <<
      endl; erturn 0;}

이렇게 작성하는 것도 가능하다.

    int ma in()       // 이름 안에 빈칸이 있어서 틀리다
    re
    turn 0;           // 키워드 안에 캐리지 리턴이 있어서
    cout << "Behold the Beans
    of Beauty!";      //문자열 안에 캐리지 리턴이 있어서 틀리다

## cin을 이용한 입력 

    cin >> carrots; 
    
 이 코드로 cin에 있는 값을 carrots 쪽으로 흐른다는 것을 보여주는 코드다
 
 cin은 키보드로 넣은 일련의 문자들인 입력을 그것을 저장할 변수가 받아들이는 형태로 바꾼다.

## cout에 의한 출력의 결합

iostream 파일에는 << 연산자가 여러 개의 출력을 하나로 결합(연결)
있도록 정의되어 있다

    cout << "이제 당근은 모두 " << carrots << "개이다." << endl;

이것은 문자열 출력과 정수 출력을 하나의 구문으로 결함한다. 이것의 실행 결
다음과 같은 세 행의 코드가 만들어 내는 결과와 동일하다.

    cout << "이제 당근은 모두"; 
    cout << carrots;
    cout << "개이다.";
    cout << endl;

또한 독자가 cout 을 사용하리는 권고를 받아들이기로 했다면, 하나로 결합된 .
구문을 다음과 같이 네 행에 결쳐 작성할 수도 있다.

    cout << "이제 당근은 모두"
    << carrots
    << "개이다."
    << endl; 
  

## 함수

C++에는 함수의 유형이 2가지가 있다.

    1. 리턴값이 있는 것과 리턴값이 없는 것
    2. 표준 함수 라이브러리에 있는 함수를 사용할 수도 있고 사용자가 직접 만들어 사용할 수도 있다.

### 리턴값이 있는 함수

리턴값이 있는 함수는 변수에 대입할 수 있는 하나의 값을 만들어 낸다.

![sqrt](https://github.com/Idealm99/idealm99.github.io/assets/112872986/28e03538-3844-4239-b605-2e04f83d244a)

함수가 잡업을 끝내면 구문에 있는 함수 호출이 그 리턴값으로 대체된다.

즉 매게변수는 함수에 전달되는 정보이고, 리턴값은 함수가 돌려주는 값이다

실수를 c++에서는 double형으로 나타낸다 

    double sqrt(double);   //함수원형
    앞의 double은 sqrt() 함수가 double형의 값을 리턴한다는 뜻이고
    뒤의 double은 sqrt() 함수가 double형의 매개변수를 전달받는다는 뜻이다.

    double x;        // x를 double형 변수로 선언한다.
    x = sqrt(6.25);
    
### 변이 함수들

    double pow (double , double);   //2개의 매개변수를 가진 함수 원형
    int rand(void);                 // 매개변수가 없는 함수 원형
    myGuess = rand();               // 매개변수가 없는 함수 호출
    void bucks(double);             // 리턴값이 없는 함수 원형
    bucks(1.54);                    // 리턴값이 없는 함수 호출

### 사용자 정의 함수

    #include <iostream>
    void simon(int);
    int main() 
    {
        using namespace std;
        simon(3);
        return 0;
    }
    void simon( int n)
    {
       using namespace std;
       cout << "simon 왈 발가락을" << n << "번 두드려라." << endl;
    }

    출력물
    simon 왈 발가락을 3번 두드려라.

이러한 결과물이 된다 simon이라는 함수를 만들고 void simon( int n)에서 () 안에 입력받을 변수 타입을 정해주고
 main에서 함수를 호출하면 이렇게 simon함수 안에 있는 것들이 실행된다.

 만약 simple - simon(3); 이면 void형 함수이므로 이렇게 사용할 수 없다.
 
 ### 리턴값이 있는 사용자 정의 함수

 
# 데이터 처리<a class="anchor" id="3"></a>

## 변수 이름

    * 변수 이름에는 영문자,숫자,밑줄 문자만을 사용할 수 있다.
    * 숫자를 변수 이름의 첫 문자로 사용할 수 없다.
    * 변수 이름에 대문자와 소문자는 구별된다
    * C++의 키워드는 변수 이름으로 사용할 수 없다
    * 두개의 밑줄 문자로 시작하는 이름이나 밑줄 문자와 대문자로 시작하는 이름은 그것을 사용하는 컴파일러와 리소스가
    하나의 밑줄은 컴파일러와 리소스가 전역 식별자로 사용
    * 변수 이름의 제한이 없으며 변수 이름에 쓰인 모든 문자들이 유효하다.

## 정수형 

정수는 2, 54 87 같이 소수부가 없는  수를 말한다. 그런데 컴퓨터의 메모리 용향에는 한계가 있으므로 길이가 제한된다.
양수값과 음수값 모두 나타낼 수 있으나 unsigned 데이터형은 양수값만 나타낼 수 있다.
기본 정수형 크기 순서로는

    char < short < int < long < long long 순이다.
    *short 16bit
    *int 32bit
    *long long 64bit more

    선언 방법

    *short score;
    *int score;
    *long score;

### 데이터 크기 알아내는 방법

1. sizeof 연산자 데이터형의 크기를 바이트 단위로 리턴한다
2. climits 헤더 파일 열어 보는 방법

climits에 정의되어 있는 기호 상수들

![climits](https://github.com/Idealm99/idealm99.github.io/assets/112872986/3d32c2af-3fa2-4be2-aba9-c439cab06e9a)

### 초기화 

초기화는 선언과 대입을 하나로 조합한다. 에로

    int n_int = INT_MAX;
    int uncle = 5; //uncle 5로 초기화
    int uncle(5);  // C++의 새로운 초기화 문법

## unsigned 형

C++ 의 unsigned 형은 부호가 없는 정수형입니다. 부호가 없는 정수는 양수만 저장할 수 있습니다. unsigned 형의 범위는 부호가 있는 정수형의 범위보다 큽니다. 예를 들어, unsigned int 의 범위는 0 ~ 4294967295 이고, int 의 범위는 -2147483648 ~ 2147483647 입니다.

unsigned 형을 사용하는 이유는 다음과 같습니다.

* 양수만 저장해야 할 때
* 부호가 있는 정수형보다 더 큰 범위의 정수를 저장해야 할 때
* 부호 오류를 방지해야 할 때

unsigned 형을 사용할 때는 다음과 같은 점에 유의해야 합니다.

* unsigned 형은 부호가 없는 정수형이기 때문에 음수를 저장할 수 없습니다.
* unsigned 형과 부호가 있는 정수형을 연산할 때는 부호가 있는 정수형을 unsigned 형으로 변환합니다.
* unsigned 형과 부호가 있는 정수형의 범위가 다르기 때문에 unsigned 형으로 변환할 때는 주의해야 합니다.

unsigned 만 있는 것은 unsigned int 를 줄여서 나타낸 것이다.

## C++가 상수의 데이터형을 결정하는 방법

1. 상수의 값을 기준으로 데이터형을 결정합니다.
2. 상수의 이름에 접미어를 붙여 데이터형을 지정할 수 있습니다.
3. 상수의 데이터형을 명시적으로 지정할 수 있습니다.

예를 들어, 상수의 값이 100이면 int형으로 결정됩니다. 상수의 이름에 접미어를 붙여 데이터형을 지정할 수도 있습니다. 예를 들어, `const int a = 100;`은 int형 상수 `a`를 선언합니다. 상수의 데이터형을 명시적으로 지정할 수도 있습니다. 예를 들어, `const int a = 100u;`은 unsigned int형 상수 `a`를 선언합니다.

## char 형 문자와 작은 정수

문자와 숫자를 저장하기 위한 형태이다.

char형은 문자들을 처리하는데 사용할 수도 있다.

예를 들어서 ASCII 에서 A는 65다

    char ch= 65;
    cout << ch

    출력물 = A
    

입력할 때 문자 A에 해당하는 코드인 65을 ch에 입력하면 숫자가 아닌 그에 해당하는 문자인 A가 나온다.
이것은 char가 바꾸는 것이 아닌 cout에서 변환하는 것이다.

cout.put(A);은 ASCII로 변환하지 않고 문자 그대로 나오게 한다.

    char alarm = '|a';
    cout << alarm << "틀렸습니다!|a|n";
    cout << "정답은|n 김소월의 |"진달래 꽃|"입니다!|n";

    *실행 결과*
    정답은
    김소월의 "진달래 꽃"입니다!

![이스케이프](https://github.com/Idealm99/idealm99.github.io/assets/112872986/12d4b318-0e96-4ff9-a916-49945f47a8db)














 
