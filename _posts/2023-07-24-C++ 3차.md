---
layout: single
title:  "C++ 9장 메모리 모델과 이름 공간 "
categories: coding
toc: true
toc_sticky: true
author_profile: false
---

# 9장 메모리 모델과 이름 공간

## 9.1 분할 컴파일

파일들을 개별적으로 분할하여 컴파일한 후에 그것들을 하나의 최종 실행 프로그램으로 링크할 수 있다.

#include 기능

각각의 파일에 구조체 선언을 넣는 대신에 그것을 해더 파일에 넣은 후 그 헤더 파일을 각각의 소스 파일에 포합시킨다.

 - 구조체 정의 변경할 때 한번만 변경하면 된다.

* 헤더 파일에 넣을 수 있는 것

1. 함수 원형
2. #define이나 const를 사용하여 정의하는 기호 상수 - 특별 링크 속성
3. 구조체 선언 - 변수를 만들지 않기 때문에 가능 ( 변수를 선언했을 때 그것을 만드는 방법을 컴파일러에게 지시)
4. 클래스 선언
5. 템플릿 선언 - 함수 정의를 생성하는 방법을 컴파일러에게 지시
6. 인라인 함수

* 주의할점

1. 헤더 파일은 프로젝트에 추가할 수 없다. 소스 코드 파일만 프로젝트에 추가 가능하다
2. #include를 사용하여 소스 코드 파일을 포함시키면 안된다
- 중복될 수 있기 때문이다.

소스 코드 파일 : .cpp

헤더 파일      : .h 
 

```cpp
// coordin.h -- structure templates and function prototypes
// structure templates
#ifndef COORDIN_H_
#define COORDIN_H_

struct polar
{
    double distance;    // distance from origin
    double angle;        // direction from origin
};
struct rect
{
    double x;        // horizontal distance from origin
    double y;        // vertical distance from origin
};

// prototypes
polar rect_to_polar(rect xypos);
void show_polar(polar dapos); 

#endif
```

```cpp
#include <iostream>
#include "coordin.h" // structure templates, function prototypes
using namespace std;
int main()
{
    rect rplace;
    polar pplace;

    cout << "Enter the x and y values: ";
    while (cin >> rplace.x >> rplace.y)  // slick use of cin
    {
        pplace = rect_to_polar(rplace);
        show_polar(pplace);
        cout << "Next two numbers (q to quit): ";
    }
    cout << "Bye!\n";
// keep window open in MSVC++
/*
    cin.clear();
    while (cin.get() != '\n')
        continue;
    cin.get();
*/
    return 0; 
}

```


###  (<coordin.h>) 와 "coordin.h" 의 차이


(</coordin.h>/)은 컴파일러는 표준 헤더 파일들이 들어 있는 호스트 시스템의 파일 시스템 영역에서 그것을 찾는다.

"coordin.h" 은 먼저 현재 작업 디렉토리나 소스 코드 디렉토리에서 그것을 찾는다

사용자가 만든 헤더 파일을 포합시킬 때에는 "coordin.h" 를 사용한다.

     #include "coordin.h"  //구조체 템플릿, 함수 원형

 ---   

##  9.2 기억 존속 시간, 사용 범위, 링크

* 데이터 저장 유형

1. 자동 기억 존속 시간 : 변수가 메모리에 할당되고 해제되는 시간을 나타내
2. 정적 기억 존속 시간 : 함수 정의의 바깥에서 정의된 변수 또는 static을 사용하여 정의된 변수
                        변수가 프로그램 실행 동안 메모리에 계속 유지되는 시간을 나타냅니다
3. 쓰레드 존속 시간:     멀티코어 프로세서를 사용하여 연산 작업을 쓰레드 단위로 쪼개서 처리
4. 동적 기억 존속 시간 : new연산자를 사용하여 delete 연산자로 해제될 때 까지 시간

### 사용 범위와 링크

사용범위 : 어떤 이름이 하나의 파일 안에서 얼마나 널리 알려지는가

링크 : 서로 다른 번역 단위들이 이릉ㅁ을 공유하는 것 

    외부 링크 : 여러 파일들이 공유할 수 있다
    내부 링크 : 한 파일 안에 있는 함수들만 공유할 수 있다.
    (자동 변수는 공유되지 않기 때문에 자동 변수의 이름은 링크를 갖지 않는다.

* 변수의 사용 범위

     지역(블록) 사용 범위 : 그 블록(괄호) 안에서만 사용 가능하다.
     전역 사용 범위 : 그 아래로 파일 전체에 걸쳐 사용 가능하다

자동 변수 - 지역 사용 범위
정적 변수 - 어떻게 사용하느냐에 따라 둘 다 가능


### 자동 변수

자동 기억 존속 시간, 지역 사용 범위, 링크가 없다

예를 들어서 

```
int A= 5;  // 1번 A
```
```
oil(){
int A =4; // 2번 A
}
```

1번과 2번 A는 독립적이고 자신이 정의된 함수 안에서만 사용 가능하다

서로 영향을 끼치지 않는다. 


```cpp

// autoscp.cpp -- 자동 변수의 범위를 설명하는 예제
#include <iostream>
void oil(int x);
int main()
{
    using namespace std;

    int texas = 31;
    int year = 2011;
    cout << "main() 함수 내에서, texas = " << texas << ", &texas = ";
    cout << &texas << endl;
    cout << "main() 함수 내에서, year = " << year << ", &year = ";
    cout << &year << endl;
    oil(texas);
    cout << "main() 함수 내에서, texas = " << texas << ", &texas = ";
    cout << &texas << endl;
    cout << "main() 함수 내에서, year = " << year << ", &year = ";
    cout << &year << endl;
    return 0;
}

void oil(int x)
{
    using namespace std;
    int texas = 5;

    cout << "oil() 함수 내에서, texas = " << texas << ", &texas = ";
    cout << &texas << endl;
    cout << "oil() 함수 내에서, x = " << x << ", &x = ";
    cout << &x << endl;
    {                               // 블록 시작
        int texas = 113;
        cout << "블록 내에서, texas = " << texas;
        cout << ", &texas = " << &texas << endl;
        cout << "블록 내에서, x = " << x << ", &x = ";
        cout << &x << endl;
    }                               // 블록 종료
    cout << "블록 이후의 texas = " << texas;
    cout << ", &texas = " << &texas << endl;
}

```

출력물

```
main() 함수 내에서, texas = 31, &texas = 0x7ffe025f36e0
main() 함수 내에서, year = 2011, &year = 0x7ffe025f36e4
oil() 함수 내에서, texas = 5, &texas = 0x7ffe025f36c0
oil() 함수 내에서, x = 31, &x = 0x7ffe025f36bc
블록 내에서, texas = 113, &texas = 0x7ffe025f36c4
블록 내에서, x = 31, &x = 0x7ffe025f36bc
블록을 통과한 후, texas = 5, &texas = 0x7ffe025f36c0
main() 함수 내에서, texas = 31, &texas = 0x7ffe025f36e0
main() 함수 내에서, year = 2011, &year = 0x7ffe025f36e4

```

위 코드에서 보듯이 texas는 다른 블록에 위치하면 서로 영향을 끼치지 않는다


통과한 후 다시 원래 값으로 돌아가는 모습을 볼 수 있다.

#### 자동 변수의 생성 과정

함수가 호출되면, 현재 함수의 상태(로컬 변수 값, 복귀 주소 등)를 스택에 저장하고 

새로운 함수 프레임을 생성합니다.

함수 내에서 선언된 자동 변수들은 이 프레임에 할당되고,

함수 실행이 종료되면 해당 프레임과 함께 자동 변수들도 스택에서 제거됩니다.


함수가 다른 함수를 호출하면, 

새로운 함수의 프레임이 생성되고 해당 함수 내에서 선언된 변수들이 그 프레임에 할당됩니다.


함수들이 순차적으로 반환되면,

스택에서 가장 최근에 생성된 함수 프레임부터 제거되면서 이전 상태로 복구됩니다.

스택은 자동 변수들의 수명과 범위를 관리하고, 함수 호출과 복귀를 처리하는 데 중요한 역할을 합니다. 

#### 레지스터 변수

컴파일러가 CPU 레지스터를 사용해서 자동 변수를 저장할 것을 제안한다.

변수에 더욱 빨리 접근하는 것을 허용하기 위함

register 을 변수 선언 앞에 붙이면 되는데 

이 코드를 사용하는 기존의 코드가 인식이 불가능해지는 것을 방지하기 위해서 사용한다

---

### 정적 변수

정적 변수 = 외부 링크, 내부 링크, 링크 없음

세가지 유형 모두 프로그램이 실행되는 전체 시간 동안 존속한다.

프로그램이 실행되는 동안 계속 존재한다. 그리고 명시적으로 초기화하지 않으면 모두 0으로 초기화한다.

* 정적 변수 선언 방식

외부 링크 정적변수  : 어떠한 블록에도 속하지 않는 곳에서 선언

내부 링크 정적 변수 : 어떠한 블록에도 속하지 않는 곳에서 static을 붙여서 선언

링크 없는 정적 변수 : 블록 내부에서 static을 붙여서 선언

```
int A = 1000;   // 외부 링크
static int B = 50; //내부링크

int main(){

}
void funct1 (int n)
{
static int count = 0;  // 링크 없음
int liama=0;
}
```

count와 liama의 차이점은 count는 함수가 실행되고 있지 않을 때에도 메모리에 계속해서 존재한다

count와 liama의 공통점은 둘 다 블록 내에서만 사용 가능하다.

---

A와 B의 차이점은 B는 이 코드가 담겨 있는 파일에서만 사용 가능하고 

A는 프로그램을 구성하는 다른 파일에서도 사용할 수 있다.


아래는 다섯 가지 기억 공간(저장 클래스)에 관한 정보를 표로 정리한 것입니다.

| 기억 공간      | 기억 존속 시간    | 사용 범위        | 링크                       | 선언 방법                          |
|----------------|------------------|------------------|----------------------------|-----------------------------------|
| 자동 (Automatic)  | 자동 | 블록 내에서만 유효 |    없음      | 함수 내부에 변수를 선언하여 사용   |
| 레지스터 (Register) | 자동 | 블록 내에서만 유효 | 없음 | 블록안에(변수 앞에 `register` 키워드 사용)   |
| 링크 없는 정적 (Static without Linkage) | 정적 | 블록 내에서만 유효    | 없음 | 함수 내에서 `static` 키워드를 사용하여 변수를 선 |
| 외부 링크 정적 (External Linkage Static) | 정적  | 파일 외부에서 유효  | 외부 | 함수 바깥에 |
| 내부 링크 정적 (Internal Linkage Static) | 정적 | 파일 내에서 유효    | 내부 | 함수 바깥에 `static` 키워드를 사용하여 변수를 선언 |

### 정적 존속 시간, 외부 링크

* C++의 두 종류의 변수 선언

1. 선언을 정의하는 것 또는 단순하게 정의로 대입되는 변수에 대하여 저장소를 제공
2. 참조 선언 혹은 단순히 선언(저장소 생성 X)

####  extern 참조 선언

1. 초기화 제공 X
2. 초기화 되면 정의이며 저장소가 대입된다.

```
double up;    // 정의 값은 0임
extern int blem;  // blem은 다른 지역에서 정의
extern char gr = 'z'  //초기화되므로 선언이다.



#include <stdio.h>

extern char gr;

int main() {
    printf("gr value: %d\n", gr);
    return 0;
}


```
이렇게 다른 파일에서 선언한 gr의 값을 받아오는 코드의 결과는 

'z' 가 출력된다. blem은 값을 받아오면 초기화를 시켜줘야 하며 안하면 0의 값이 된다.

즉, 다른 파일에 저장된 외부(전역) 변수를 불러오기 위해서 extern 참조 선언을 하고 값을 가져오는 것 이다.


C++에서 함수의 선언과 정의를 분리하는 방법은 주로 "헤더 파일"과 "소스 파일"을 사용하는 것입니다. 함수의 선언은 헤더 파일에 작성하고, 함수의 정의는 소스 파일에 작성합니다. 이렇게 하면 여러 소스 파일에서 동일한 함수를 사용할 수 있습니다.

먼저, 메인 파일(`main.cpp`)에서 함수를 선언한 헤더 파일(`functions.h`)과 정의를 포함하는 소스 파일(`functions.cpp`)로 구성된 코드입니다.

1. `functions.h` (헤더 파일):

```cpp
#ifndef FUNCTIONS_H
#define FUNCTIONS_H

void update(double dt);
void local();

#endif
```

2. `functions.cpp` (소스 파일):

```cpp
#include "functions.h"
#include <iostream>

extern double warming; // 외부 파일에서 정의된 전역 변수 사용

void update(double dt)
{
    warming += dt;
    std::cout << "Updating global warming to " << warming;
    std::cout << " degrees.\n";
}

void local()
{
    double warming = 0.8;
    std::cout << "Local warming = " << warming << " degrees.\n";
    std::cout << "But global warming = " << ::warming;
    std::cout << " degrees.\n";
}
```

3. `main.cpp` (메인 파일):

```cpp
#include "functions.h"
#include <iostream>

double warming = 0.3;

int main()
{
    std::cout << "Global warming is " << warming << " degrees.\n";
    update(0.1);
    std::cout << "Global warming is " << warming << " degrees.\n";
    local();
    std::cout << "Global warming is " << warming << " degrees.\n";
    return 0;
}
```

위와 같이 코드를 구성하면 `main.cpp`에서는 `functions.h` 헤더 파일을 포함하여

함수 `update()`와 `local()`의 선언을 가져올 수 있습니다.

이후에 `functions.cpp`에서 해당 함수들을 정의하고, 

외부에서 정의된 `warming` 변수를 사용하고 있음을 `extern double warming;` 문으로 선언하여 알려주었습니다.


또한, 컴파일 시에 `main.cpp`와 `functions.cpp`를 함께 컴파일하면 

두 소스 파일이 하나의 실행 파일로 합쳐질 것입니다.

이렇게 구성하면 함수를 다른 파일에서 정의해도, 메인 파일에서 해당 함수들을 사용할 수 있게 됩니다.

### 정적 존속 시간, 내부 링크

파일 사용 범위가 있는 변수에 static 을 적용하면 내부 링크를 부여하게 된다.

* 내부링크 vs 외부링크

     내부링크: 그 변수를 포함하고 있는 파일에서만 사용 가능
     외부링크: 다른 파일에서 서로 다른 변수들에게 같은 이름을 사용하기를 원한다

* static을 사용하는 이유

```
//file 1
int errors = 20; //외부 선언

//----------

//file 2

static int errors = 5;
{
cout << errors;
}
```
위 코드에서 만약 static이 없다면 파일 1과 2의 errors가 2개 생겨서 오류가 발생한다

그래서 file2에서만 따로 만든 errors를 사용하고 싶어서 변수 선언 할 때 static을 붙인거다.

### 정적 기억 존속 시간, 링크 없음

링크 없음은 static을 블록 안에 사용하는 것이다

1. 블록 안에서 static을 사용하면 static이 지역 변수를 정적 기억 존속 시간을 갖게 만든다.
2. 블록 안에서만 존재하지만, 그 블록이 활동하지 않는 동안에도 게속 존재한다는 것을 의미한다.
3. 정적 지역 변수를 초기화하면, 프로그램은 시작할 때 한 번만 초기화한다.(다시 초기화 X)

```cpp
void strcount(const char * str)
{
    using namespace std;
    static int total = 0;        // static local variable
    int count = 0;               // automatic local variable

    cout << "\"" << str <<"\" contains ";
    while (*str++)               // go to end of string
        count++;
    total += count;
    cout << count << " characters\n";
    cout << total << " characters total\n";
}
```
여기서 total의 값은 유지되어서 함수를 호출할 때 마다 유지된 값이 증가한다.

### 제한자

제한자(Storage Class Specifiers)는 C++에서 변수와 함수의 저장 및 사용 규칙을 지정하는 키워드들입니다. 

다음은 C++에서 사용되는 주요 제한자들과 간단한 설명을 표로 정리한 것입니다:

| 제한자             | 설명                                                                                                    |
|-------------------|-------------------------------------------------------------------------------------------------------|
| `auto`            | 기본 설정으로 지정된 제한자. 함수 내 지역 변수에 사용되며, 자동으로 할당된 메모리 공간을 갖습니다.        |
| `register`        | 변수를 레지스터에 저장하도록 요청하는 제한자. 실제로 레지스터에 저장될지는 컴파일러가 결정합니다.         |
| `static`          | 정적 기억 존속 시간을 갖는 변수와 함수를 나타내는 제한자. 파일 외부에서는 사용되지 않도록 합니다.           |
| `extern`          | 외부 링크를 갖는 전역 변수를 나타내는 제한자. 다른 파일에서 선언된 전역 변수와 공유됩니다.                 |
| `mutable`         | 클래스의 멤버 변수로 사용되며, `const` 멤버 함수 내에서도 수정할 수 있음을 나타냅니다.                      |
| `const`           | 상수 변수를 나타내는 제한자. 값이 변경되지 않음을 나타내며, 컴파일러가 이를 강제합니다.                    |
| `volatile`        | 변수가 예기치 않게 변경될 수 있음을 나타내는 제한자. 최적화 과정에서 변수의 값을 무시하지 않도록 합니다.    |
| `thread_local`    | 스레드 지역 변수를 나타내는 제한자. 각 스레드마다 고유한 인스턴스를 갖습니다.                          |
| `mutable`         | `const` 함수 내에서도 값 변경이 가능한 멤버 변수를 나타내는 제한자.                                    |

이러한 제한자들은 변수와 함수를 선언할 때 사용되며, 

각 제한자의 동작은 변수의 스코프, 수명, 메모리 할당 등을 결정하는 데 영향을 미칩니다.

제한자를 올바르게 사용하여 코드를 구성하면 메모리 사용과 성능을 최적화하고, 유지 보수성을 높일 수 있습니다.

### 함수와 링크

함수는 기보적으로 외부 링크를 가진다.


static 키워드를 사용하여 함수에 내부 링크를 부여할 수 있다.

이것은 그 함수의 사용 범위를 하나의 파일로 제한한다.

    static int private( double x);

    ....
    
    static int private( double x)
    {
    ...
    }

이것은 그 함수가 그 파일에만 알려진다는 것을 의미한다.

같은 이름의 함수를 다른 파일에서도 사용할 수 있다.

### 언어 링크 

함수에 영향을 준다.

C++ 컴파일러는 오버로딩된 함수들에 대해서 서로 다른 기호 이름을 생성하기 위해서 

맹글링 또는 이름 장식 과정을 거친다 

    ex) spiff(int) -> _spiff_i
        spiff(double, double) -> _spiff_d_d
        이러한 과정을 c++ 언어 링크라고 한다

    extern void spoff(int) //c++ 프로토콜을 사용하여 이름을 찾는다
    extern "C++" void spaff(int) //c++ 프로토콜을 사용하여 이름을 찾는다

### 기억 공간 형식과 동적 대입

동적 메모리는 어떤 하나의 함수로부터 대입받고 다른 함수에서 이를 해제할 수 있다.

대입 순서와 해제 순서가 new와 delete를 언제 어떻게 사용하느냐에 따라 달라진다.

![image](https://github.com/Idealm99/idealm99.github.io/assets/112872986/6dfcb6d0-117b-435f-bab6-dbd2ebeedc70)

P 를 외부 링크를 갖도록 선언하면 파일에서 그 선언의 뒤에 오는 모든 함수에서 p 포인터를 사용할 수 있다

선언 방법은

    extern float * p;

#### new 연산자를 이용한 초기화

```
int *pi = new int (7);
double *pd = new double (99.9);

```

순차적인 구조체나 변수를 초기화하기 위해서는 중괄호를 이용한 리스트 초기화를 사용해야 한다.

```
struct where { double x; double y; double z;};
where * one = new where {2.5, 5.3, 7.2};








    
 







