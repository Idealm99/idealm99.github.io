---
layout: single
title:  "C++ 9장 메모리 모델과 이름 공간 "
categories: coding
toc: true
toc_sticky: true
toc_max_heading_level: 1
author_profile: false
---

# 9장 메모리 모델과 이름 공간

## 9.1 분할 컴파일

파일들을 개별적으로 분할하여 컴파일한 후에 그것들을 하나의 최종 실행 프로그램으로 링크할 수 있다.

#include 기능

```
각각의 파일에 구조체 선언을 넣는 대신에 그것을 해더 파일에 넣은 후 그 헤더 파일을 각각의 소스 파일에 포합시킨다.

 - 구조체 정의 변경할 때 한번만 변경하면 된다.

* 헤더 파일에 넣을 수 있는 것

1. 함수 원형
2. #define이나 const를 사용하여 정의하는 기호 상수 - 특별 링크 속성
3. 구조체 선언 - 변수를 만들지 않기 때문에 가능 ( 변수를 선언했을 때 그것을 만드는 방법을 컴파일러에게 지시)
4. 클래스 선언
5. 템플릿 선언 - 함수 정의를 생성하는 방법을 컴파일러에게 지시
6. 인라인 함수

* 주의할점

1. 헤더 파일은 프로젝트에 추가할 수 없다. 소스 코드 파일만 프로젝트에 추가 가능하다
2. #include를 사용하여 소스 코드 파일을 포함시키면 안된다
- 중복될 수 있기 때문이다.

소스 코드 파일 : .cpp
헤더 파일      : .h 
 

```

```cpp
// coordin.h -- structure templates and function prototypes
// structure templates
#ifndef COORDIN_H_
#define COORDIN_H_

struct polar
{
    double distance;    // distance from origin
    double angle;        // direction from origin
};
struct rect
{
    double x;        // horizontal distance from origin
    double y;        // vertical distance from origin
};

// prototypes
polar rect_to_polar(rect xypos);
void show_polar(polar dapos); 

#endif
```

```cpp
#include <iostream>
#include "coordin.h" // structure templates, function prototypes
using namespace std;
int main()
{
    rect rplace;
    polar pplace;

    cout << "Enter the x and y values: ";
    while (cin >> rplace.x >> rplace.y)  // slick use of cin
    {
        pplace = rect_to_polar(rplace);
        show_polar(pplace);
        cout << "Next two numbers (q to quit): ";
    }
    cout << "Bye!\n";
// keep window open in MSVC++
/*
    cin.clear();
    while (cin.get() != '\n')
        continue;
    cin.get();
*/
    return 0; 
}

```


### <coordin.h> 와 "coordin.h" 의 차이

<coordin.h>은 컴파일러는 표준 헤더 파일들이 들어 있는 호스트 시스템의 파일 시스템 영역에서 그것을 찾는다.


"coordin.h" 은 먼저 현재 작업 디렉토리나 소스 코드 디렉토리에서 그것을 찾는다

사용자가 만든 헤더 파일을 포합시킬 때에는 "coordin.h" 를 사용한다.

    #include "coordin.h"  //구조체 템플릿, 함수 원형

    

## 9.2 기억 존속 시간, 사용 범위, 링크

* 데이터 저장 유형

1. 자동 기억 존속 시간 : 변수가 메모리에 할당되고 해제되는 시간을 나타내
2. 정적 기억 존속 시간 : 함수 정의의 바깥에서 정의된 변수 또는 static을 사용하여 정의된 변수
                        변수가 프로그램 실행 동안 메모리에 계속 유지되는 시간을 나타냅니다
3. 쓰레드 존속 시간:     멀티코어 프로세서를 사용하여 연산 작업을 쓰레드 단위로 쪼개서 처리
4. 동적 기억 존속 시간 : new연산자를 사용하여 delete 연산자로 해제될 때 까지 시간

### 사용 범위와 링크

사용범위 : 어떤 이름이 하나의 파일 안에서 얼마나 널리 알려지는가

링크 : 서로 다른 번역 단위들이 이릉ㅁ을 공유하는 것 

    외부 링크 : 여러 파일들이 공유할 수 있다
    내부 링크 : 한 파일 안에 있는 함수들만 공유할 수 있다.
    (자동 변수는 공유되지 않기 때문에 자동 변수의 이름은 링크를 갖지 않는다.



