---
layout: single
title:  "C++ 9장 메모리 모델과 이름 공간 "
categories: coding
toc: true
toc_sticky: true
author_profile: false
---

# 9장 메모리 모델과 이름 공간

## 9.1 분할 컴파일

파일들을 개별적으로 분할하여 컴파일한 후에 그것들을 하나의 최종 실행 프로그램으로 링크할 수 있다.

#include 기능

각각의 파일에 구조체 선언을 넣는 대신에 그것을 해더 파일에 넣은 후 그 헤더 파일을 각각의 소스 파일에 포합시킨다.

 - 구조체 정의 변경할 때 한번만 변경하면 된다.

* 헤더 파일에 넣을 수 있는 것

1. 함수 원형
2. #define이나 const를 사용하여 정의하는 기호 상수 - 특별 링크 속성
3. 구조체 선언 - 변수를 만들지 않기 때문에 가능 ( 변수를 선언했을 때 그것을 만드는 방법을 컴파일러에게 지시)
4. 클래스 선언
5. 템플릿 선언 - 함수 정의를 생성하는 방법을 컴파일러에게 지시
6. 인라인 함수

* 주의할점

1. 헤더 파일은 프로젝트에 추가할 수 없다. 소스 코드 파일만 프로젝트에 추가 가능하다
2. #include를 사용하여 소스 코드 파일을 포함시키면 안된다
- 중복될 수 있기 때문이다.

소스 코드 파일 : .cpp

헤더 파일      : .h 
 

```cpp
// coordin.h -- structure templates and function prototypes
// structure templates
#ifndef COORDIN_H_
#define COORDIN_H_

struct polar
{
    double distance;    // distance from origin
    double angle;        // direction from origin
};
struct rect
{
    double x;        // horizontal distance from origin
    double y;        // vertical distance from origin
};

// prototypes
polar rect_to_polar(rect xypos);
void show_polar(polar dapos); 

#endif
```

```cpp
#include <iostream>
#include "coordin.h" // structure templates, function prototypes
using namespace std;
int main()
{
    rect rplace;
    polar pplace;

    cout << "Enter the x and y values: ";
    while (cin >> rplace.x >> rplace.y)  // slick use of cin
    {
        pplace = rect_to_polar(rplace);
        show_polar(pplace);
        cout << "Next two numbers (q to quit): ";
    }
    cout << "Bye!\n";
// keep window open in MSVC++
/*
    cin.clear();
    while (cin.get() != '\n')
        continue;
    cin.get();
*/
    return 0; 
}

```


###  (<coordin.h>) 와 "coordin.h" 의 차이


(<coordin.h>)은 컴파일러는 표준 헤더 파일들이 들어 있는 호스트 시스템의 파일 시스템 영역에서 그것을 찾는다.

"coordin.h" 은 먼저 현재 작업 디렉토리나 소스 코드 디렉토리에서 그것을 찾는다

사용자가 만든 헤더 파일을 포합시킬 때에는 "coordin.h" 를 사용한다.

     #include "coordin.h"  //구조체 템플릿, 함수 원형

 ---   

##  9.2 기억 존속 시간, 사용 범위, 링크

* 데이터 저장 유형

1. 자동 기억 존속 시간 : 변수가 메모리에 할당되고 해제되는 시간을 나타내
2. 정적 기억 존속 시간 : 함수 정의의 바깥에서 정의된 변수 또는 static을 사용하여 정의된 변수
                        변수가 프로그램 실행 동안 메모리에 계속 유지되는 시간을 나타냅니다
3. 쓰레드 존속 시간:     멀티코어 프로세서를 사용하여 연산 작업을 쓰레드 단위로 쪼개서 처리
4. 동적 기억 존속 시간 : new연산자를 사용하여 delete 연산자로 해제될 때 까지 시간

### 사용 범위와 링크

사용범위 : 어떤 이름이 하나의 파일 안에서 얼마나 널리 알려지는가

링크 : 서로 다른 번역 단위들이 이릉ㅁ을 공유하는 것 

    외부 링크 : 여러 파일들이 공유할 수 있다
    내부 링크 : 한 파일 안에 있는 함수들만 공유할 수 있다.
    (자동 변수는 공유되지 않기 때문에 자동 변수의 이름은 링크를 갖지 않는다.

* 변수의 사용 범위

     지역(블록) 사용 범위 : 그 블록(괄호) 안에서만 사용 가능하다.
     전역 사용 범위 : 그 아래로 파일 전체에 걸쳐 사용 가능하다

자동 변수 - 지역 사용 범위
정적 변수 - 어떻게 사용하느냐에 따라 둘 다 가능


### 자동 변수

자동 기억 존속 시간, 지역 사용 범위, 링크가 없다

예를 들어서 

```
int A= 5;  // 1번 A
```
```
oil(){
int A =4; // 2번 A
}
```

1번과 2번 A는 독립적이고 자신이 정의된 함수 안에서만 사용 가능하다

서로 영향을 끼치지 않는다. 


```cpp

// autoscp.cpp -- 자동 변수의 범위를 설명하는 예제
#include <iostream>
void oil(int x);
int main()
{
    using namespace std;

    int texas = 31;
    int year = 2011;
    cout << "main() 함수 내에서, texas = " << texas << ", &texas = ";
    cout << &texas << endl;
    cout << "main() 함수 내에서, year = " << year << ", &year = ";
    cout << &year << endl;
    oil(texas);
    cout << "main() 함수 내에서, texas = " << texas << ", &texas = ";
    cout << &texas << endl;
    cout << "main() 함수 내에서, year = " << year << ", &year = ";
    cout << &year << endl;
    return 0;
}

void oil(int x)
{
    using namespace std;
    int texas = 5;

    cout << "oil() 함수 내에서, texas = " << texas << ", &texas = ";
    cout << &texas << endl;
    cout << "oil() 함수 내에서, x = " << x << ", &x = ";
    cout << &x << endl;
    {                               // 블록 시작
        int texas = 113;
        cout << "블록 내에서, texas = " << texas;
        cout << ", &texas = " << &texas << endl;
        cout << "블록 내에서, x = " << x << ", &x = ";
        cout << &x << endl;
    }                               // 블록 종료
    cout << "블록 이후의 texas = " << texas;
    cout << ", &texas = " << &texas << endl;
}

```

출력물

```
main() 함수 내에서, texas = 31, &texas = 0x7ffe025f36e0
main() 함수 내에서, year = 2011, &year = 0x7ffe025f36e4
oil() 함수 내에서, texas = 5, &texas = 0x7ffe025f36c0
oil() 함수 내에서, x = 31, &x = 0x7ffe025f36bc
블록 내에서, texas = 113, &texas = 0x7ffe025f36c4
블록 내에서, x = 31, &x = 0x7ffe025f36bc
블록을 통과한 후, texas = 5, &texas = 0x7ffe025f36c0
main() 함수 내에서, texas = 31, &texas = 0x7ffe025f36e0
main() 함수 내에서, year = 2011, &year = 0x7ffe025f36e4

```

위 코드에서 보듯이 texas는 다른 블록에 위치하면 서로 영향을 끼치지 않는다


통과한 후 다시 원래 값으로 돌아가는 모습을 볼 수 있다.

#### 자동 변수의 생성 과정

함수가 호출되면, 현재 함수의 상태(로컬 변수 값, 복귀 주소 등)를 스택에 저장하고 

새로운 함수 프레임을 생성합니다.

함수 내에서 선언된 자동 변수들은 이 프레임에 할당되고,

함수 실행이 종료되면 해당 프레임과 함께 자동 변수들도 스택에서 제거됩니다.


함수가 다른 함수를 호출하면, 

새로운 함수의 프레임이 생성되고 해당 함수 내에서 선언된 변수들이 그 프레임에 할당됩니다.


함수들이 순차적으로 반환되면,

스택에서 가장 최근에 생성된 함수 프레임부터 제거되면서 이전 상태로 복구됩니다.

스택은 자동 변수들의 수명과 범위를 관리하고, 함수 호출과 복귀를 처리하는 데 중요한 역할을 합니다. 

#### 레지스터 변수

컴파일러가 CPU 레지스터를 사용해서 자동 변수를 저장할 것을 제안한다.

변수에 더욱 빨리 접근하는 것을 허용하기 위함

register 을 변수 선언 앞에 붙이면 되는데 

이 코드를 사용하는 기존의 코드가 인식이 불가능해지는 것을 방지하기 위해서 사용한다

---

### 정적 변수

정적 변수 = 외부 링크, 내부 링크, 링크 없음

세가지 유형 모두 프로그램이 실행되는 전체 시간 동안 존속한다.

프로그램이 실행되는 동안 계속 존재한다. 그리고 명시적으로 초기화하지 않으면 모두 0으로 초기화한다.

* 정적 변수 선언 방식

외부 링크 정적변수  : 어떠한 블록에도 속하지 않는 곳에서 선언

내부 링크 정적 변수 : 어떠한 블록에도 속하지 않는 곳에서 static을 붙여서 선언

링크 없는 정적 변수 : 블록 내부에서 static을 붙여서 선언

```
int A = 1000;   // 외부 링크
static int B = 50; //내부링크

int main(){

}
void funct1 (int n)
{
static int count = 0;  // 링크 없음
int liama=0;
}
```

count와 liama의 차이점은 count는 함수가 실행되고 있지 않을 때에도 메모리에 계속해서 존재한다

count와 liama의 공통점은 둘 다 블록 내에서만 사용 가능하다.

---

A와 B의 차이점은 B는 이 코드가 담겨 있는 파일에서만 사용 가능하고 

A는 프로그램을 구성하는 다른 파일에서도 사용할 수 있다.


아래는 다섯 가지 기억 공간(저장 클래스)에 관한 정보를 표로 정리한 것입니다.

| 기억 공간      | 기억 존속 시간    | 사용 범위        | 링크                       | 선언 방법                          |
|----------------|------------------|------------------|----------------------------|-----------------------------------|
| 자동 (Automatic)  | 자동 | 블록 내에서만 유효 |    없음      | 함수 내부에 변수를 선언하여 사용   |
| 레지스터 (Register) | 자동 | 블록 내에서만 유효 | 없음 | 블록안에(변수 앞에 `register` 키워드 사용)   |
| 링크 없는 정적 (Static without Linkage) | 정적 | 블록 내에서만 유효    | 없음 | 함수 내에서 `static` 키워드를 사용하여 변수를 선 |
| 외부 링크 정적 (External Linkage Static) | 정적  | 파일 외부에서 유효  | 외부 | 함수 바깥에 |
| 내부 링크 정적 (Internal Linkage Static) | 정적 | 파일 내에서 유효    | 내부 | 함수 바깥에 `static` 키워드를 사용하여 변수를 선언 |

### 정적 존속 시간, 외부 링크

* C++의 두 종류의 변수 선언

1. 선언을 정의하는 것 또는 단순하게 정의로 대입되는 변수에 대하여 저장소를 제공
2. 참조 선언 혹은 단순히 선언(저장소 생성 X)

####  extern 참조 선언

1. 초기화 제공 X
2. 초기화 되면 정의이며 저장소가 대입된다.

```
double up;    // 정의 값은 0임
extern int blem;  // blem은 다른 지역에서 정의
extern char gr = 'z'  //초기화되므로 선언이다.



#include <stdio.h>

extern char gr;

int main() {
    printf("gr value: %d\n", gr);
    return 0;
}


```
이렇게 다른 파일에서 선언한 gr의 값을 받아오는 코드의 결과는 

'z' 가 출력된다. blem은 값을 받아오면 초기화를 시켜줘야 하며 안하면 0의 값이 된다.

즉, 다른 파일에 저장된 외부(전역) 변수를 불러오기 위해서 extern 참조 선언을 하고 값을 가져오는 것 이다.


C++에서 함수의 선언과 정의를 분리하는 방법은 주로 "헤더 파일"과 "소스 파일"을 사용하는 것입니다. 함수의 선언은 헤더 파일에 작성하고, 함수의 정의는 소스 파일에 작성합니다. 이렇게 하면 여러 소스 파일에서 동일한 함수를 사용할 수 있습니다.

먼저, 메인 파일(`main.cpp`)에서 함수를 선언한 헤더 파일(`functions.h`)과 정의를 포함하는 소스 파일(`functions.cpp`)로 구성된 코드입니다.

1. `functions.h` (헤더 파일):

```cpp
#ifndef FUNCTIONS_H
#define FUNCTIONS_H

void update(double dt);
void local();

#endif
```

2. `functions.cpp` (소스 파일):

```cpp
#include "functions.h"
#include <iostream>

extern double warming; // 외부 파일에서 정의된 전역 변수 사용

void update(double dt)
{
    warming += dt;
    std::cout << "Updating global warming to " << warming;
    std::cout << " degrees.\n";
}

void local()
{
    double warming = 0.8;
    std::cout << "Local warming = " << warming << " degrees.\n";
    std::cout << "But global warming = " << ::warming;
    std::cout << " degrees.\n";
}
```

3. `main.cpp` (메인 파일):

```cpp
#include "functions.h"
#include <iostream>

double warming = 0.3;

int main()
{
    std::cout << "Global warming is " << warming << " degrees.\n";
    update(0.1);
    std::cout << "Global warming is " << warming << " degrees.\n";
    local();
    std::cout << "Global warming is " << warming << " degrees.\n";
    return 0;
}
```

위와 같이 코드를 구성하면 `main.cpp`에서는 `functions.h` 헤더 파일을 포함하여

함수 `update()`와 `local()`의 선언을 가져올 수 있습니다.

이후에 `functions.cpp`에서 해당 함수들을 정의하고, 

외부에서 정의된 `warming` 변수를 사용하고 있음을 `extern double warming;` 문으로 선언하여 알려주었습니다.


또한, 컴파일 시에 `main.cpp`와 `functions.cpp`를 함께 컴파일하면 

두 소스 파일이 하나의 실행 파일로 합쳐질 것입니다.

이렇게 구성하면 함수를 다른 파일에서 정의해도, 메인 파일에서 해당 함수들을 사용할 수 있게 됩니다.

### 정적 존속 시간, 내부 링크






















