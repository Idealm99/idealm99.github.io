---
layout: single
title:  "2023 C++ 2차 보고서"
categories: coding
toc: true
author_profile: false
---

<head>

  <style>
  
  @import url('https://fonts.googleapis.com/css2?family=Dongle&display=swap');

    table.dataframe {
      white-space: normal;
      width: 100%;
      height: 240px;
      display: block;
      overflow: auto;
      font-family: Arial, sans-serif;
      font-size: 0.9rem;
      line-height: 20px;
      text-align: center;
      border: 0px !important;
    }

    table.dataframe th {
      text-align: center;
      font-weight: bold;
      padding: 8px;
    }

    table.dataframe td {
      text-align: center;
      padding: 8px;
    }

    table.dataframe tr:hover {
      background: #b8d1f3; 
    }

    .output_prompt {
      overflow: auto;
      font-size: 0.9rem;
      line-height: 1.45;
      border-radius: 0.3rem;
      -webkit-overflow-scrolling: touch;
      padding: 0.8rem;
      margin-top: 0;
      margin-bottom: 15px;
      font: 1rem Consolas, "Liberation Mono", Menlo, Courier, monospace;
      color: $code-text-color;
      border: solid 1px $border-color;
      border-radius: 0.3rem;
      word-break: normal;
      white-space: pre;
    }

  .dataframe tbody tr th:only-of-type {
      vertical-align: middle;
  }

  .dataframe tbody tr th {
      vertical-align: top;
  }

  .dataframe thead th {
      text-align: center !important;
      position: sticky;
      padding: 8px;
      top = 0;
  }

  .page__content p {
      margin: 0 0 0px !important;
  }

  .page__content p > strong {
    font-size: 0.8rem !important;
  }

  </style>
</head>

# 6 분기 구문과 논리 연산자

## 6.1 if 구문

if 구문에는 if 문과 if else 두가지가 있다

-

먼저 if만 사용하는 경우

```
if(test-condition)
  statement
```
if 구문의 구문은 while 구문과 비슷하다.

test-condition에 부합하는 경우일 경우 statement 로 간다.

### 6.1.1 if else 

두 개의 구문 또는 블록 중에서 어느 쪽을 수행할 것인지를 프로그램이 결정한다 

즉, 서로 다른 작업 경로를 선택하게 만드는 유용한 구문이다.
```
int x;
cin >> x;
if( x< 5)
{                        // 단 한줄만 if문에 포함되면 괄호를 안해도 된다.
cout<<"x는 5보다 작다.";
}
else
{
cout << "x는 5보다 크다";
}
```

### 6.1.2 ifelse if else 구문

```
if (ch == 'a')
   a_grade ++;      // 선택1
else
   if (ch == 'b')   // 선택2
         b_grade++; // 하위 선택 2a
   else
        soso++;     // 하위 선택 2b
```

이렇게 한번의 선택이 아니라 여러번의 선택을 구문으로 작성할 수 있다.

## 6.2 논리 표현식

C++의 논리 연산자는 다음과 같습니다.

| 연산자 | 설명 |
|---|---|
| ㅣㅣ  | 논리합 (OR)  |
| && | 논리곱 (AND) |
| ! | 논리부정 (NOT) |

### 6.2.1 OR 연산자

논리합 연산자 (`||`)는 두 개의 피연산자의 값 중 하나라도 참일 때 참을 반환하고, 
그 외의 모든 경우는 거짓을 반환합니다.
예를 들어, `true || false`는 `true`를 반환하고, `false || true`도 `true`를 반환합니다. 
그러나 `false || false`는 `false`를 반환합니다.

* 논리합 연산자 (`||`)

```
#include <iostream>

int main() {
  bool a = true;
  bool b = false;

  std::cout << (a || b) << std::endl; // true
  std::cout << (a || a) << std::endl; // true
  std::cout << (b || b) << std::endl; // true
}
```

### 6.2.2 AND 연산자

논리곱 연산자 (`&&`)는 두 개의 피연산자의 값이 모두 참일 때만 참을 반환하고, 그 외의 모든 경우는 거짓을 반환합니다.
예를 들어, `true && false`는 `false`를 반환하고, `false && true`도 `false`를 반환합니다.
그러나 `true && true`는 `true`를 반환합니다.

* 논리곱 연산자 (`&&`)

```
#include <iostream>

int main() {
  bool a = true;
  bool b = false;

  std::cout << (a && b) << std::endl; // false
  std::cout << (a && a) << std::endl; // true
  std::cout << (b && b) << std::endl; // false
}
```

### 6.2.3 NOT 연산자

논리부정 연산자 (`!`)는 피연산자의 값이 참이면 거짓을 반환하고
, 피연산자의 값이 거짓이면 참을 반환합니다. 
예를 들어, `!true`는 `false`를 반환하고, `!false`는 `true`를 반환합니다.

* 논리부정 연산자 (`!`)

```
#include <iostream>

int main() {
  bool a = true;
  bool b = false;

  std::cout << !(a) << std::endl; // false
  std::cout << !(b) << std::endl; // true
}
```

## 6.3 문자 함수를 위한 cctype 라이브러리

네, C++의 cctype 문자 함수는 다음과 같습니다.

| 함수 | 설명 |
|---|---|
| isalnum(char c) | 문자가 알파벳 또는 숫자인지 확인합니다. |
| isalpha(char c) | 문자가 알파벳인지 확인합니다. |
| isblank(char c) | 문자가 공백 문자인지 확인합니다. |
| iscntrl(char c) | 문자가 제어 문자인지 확인합니다. |
| isdigit(char c) | 문자가 숫자인지 확인합니다. |
| isgraph(char c) | 문자가 그래픽 문자인지 확인합니다. |
| islower(char c) | 문자가 소문자인지 확인합니다. |
| isprint(char c) | 문자가 출력 가능한 문자인지 확인합니다. |
| ispunct(char c) | 문자가 구두점 문자인지 확인합니다. |
| isspace(char c) | 문자가 공백 문자인지 확인합니다. |
| isupper(char c) | 문자가 대문자인지 확인합니다. |
| isxdigit(char c) | 문자가 16진 문자인지 확인합니다. |
| tolower(char c) | 문자를 소문자로 변환합니다. |
| toupper(char c) | 문자를 대문자로 변환합니다. |

## 6.4 ?: 연산자

?: 연산자는 조건 연산자라고도 하며, 조건이 참인지 거짓인지에 따라 두 개의 값 중 하나를 선택하여 반환하는 연산자입니다. ?: 연산자는 다음과 같이 사용합니다.

```
condition ? true_value : false_value
```

condition이 참이면 true_value가 반환되고, condition이 거짓이면 false_value가 반환됩니다. 예를 들어, 다음 코드는 x가 0보다 크면 "x is greater than 0"을 반환하고, x가 0보다 작거나 같으면 "x is less than or equal to 0"을 반환합니다.

```
x > 0 ? "x is greater than 0" : "x is less than or equal to 0"
```

Output:

```
x is greater than 0
```

?: 연산자는 조건에 따라 값을 선택해야 할 때 유용하게 사용할 수 있습니다. 예를 들어, 다음 코드는 숫자가 짝수이면 "even"을 반환하고, 홀수이면 "odd"을 반환합니다.

```
number % 2 == 0 ? "even" : "odd"
```

Output:

```
even
```

## 6.5 switch구문

네, switch 구문을 좀 더 보기 쉽게 설명해드리겠습니다.

switch 구문은 특정 값이 일치하는 경우 코드를 실행하는 제어 구조입니다.

예를 들어, 다음 코드는 day의 값이 "Monday"이면 "Today is Monday", 

"Tuesday"이면 "Today is Tuesday", 

그 외의 경우 "Today is unknown"를 출력합니다.

```
String day = "Monday";

switch (day) {
  case "Monday":
    System.out.println("Today is Monday");
    break;
  case "Tuesday":
    System.out.println("Today is Tuesday");
    break;
  default:
    System.out.println("Today is unknown");
    break;
}
```

switch 구문은 다음과 같이 구성됩니다.

```
switch (expression)
case value1:
***
break;
case value2:
***
break;

default:
***
break;
```

switch 문은 expression의 값과 case value1, case value2, ...과 일치하는 경우

case value1, case value2의 코드를 실행합니다.

만약 expression의 값이 case value1, case value2 과 일치하지 않으면

default의 코드를 실행합니다.

---

switch 구문은 조건에 따라 코드를 실행해야 할 때 유용하게 사용할 수 있습니다.

예를 들어, 다음 코드는 숫자가 짝수이면 "even"을 출력하고, 홀수이면 "odd"을 출력합니다.

```
int number = 10;

switch (number % 2) {
  case 0:
    System.out.println("even");
    break;
  case 1:
    System.out.println("odd");
    break;
}
```

Output:

```
even
```

* switch 문의 단점

** switch문보다 if else 문이 더 융통성 있다. switch 구문은 값의 범위를 다룰 수 없다

** 그리고 case 레이블의 값도 상수여야한다.

* 장점

** 상수로 인식될 수 있다면 코드 크기나 실행 속도가 if else 보다 빠르다.

ex) 열거자를 사용해서

## 6.6 break , continue 구문

break와 continue 구문은 반복문을 제어하는 구문입니다. break 구문은 반복문을 종료하고, continue 구문은 다음 반복으로 넘어갑니다.

break 구문의 예는 다음과 같습니다.

```
for (int i = 0; i < 10; i++) {
  if (i == 5) {
    break;
  }
  System.out.println(i);
}
```

이 코드는 0부터 9까지 출력하지만, 5가 출력되면 반복문을 종료합니다.

continue 구문의 예는 다음과 같습니다.

```
for (int i = 0; i < 10; i++) {
  if (i % 2 == 0) {
    continue;
  }
  System.out.println(i);
}
```

이 코드는 짝수인 값은 출력하지 않고, 홀수인 값만 출력합니다.


break와 continue 구문의 차이는 break 구문이 반복문을 종료하는 반면, continue 구문은 다음 반복으로 넘어간다는 것입니다.

## 6.7 수를 읽어들이는 루프

일련의 수를 배열에 읽어들이는 프로그램을 작성한다고 가정하자 

배열이 다 차기 전에 입력을 멈출 수 있는 기회를 사용자에게 주어야 하는데

이것을 하는 한 가지 방법은 cin 이 작동하는 방식을 이용하는 것이다

1. 새로운 입력을 받아들일 수 있도록 cin을 초기화한다
2. 입력 큐에 남아 있는 불량 입력 제거한다
3. 사용자에게 다시 입력할 것을 요구한다

불량 입력을 제거하기 전에 프로그램은 먼저 cin을 초기화해야 한다는 것을 명심해야한다

```
// cingolf.cpp -- 수가아닌 입력은 무시한다다
#include <iostream>
const int Max = 5;
int main()
{
    using namespace std;
// 데이터 받기기
    int golf[Max];
    cout << "골프 점수를 입력하시오.\n";
    cout << "총 " << Max << " 라운드 점수를 입력해야 합니다.\n";
    int i;
    for (i = 0; i < Max; i++)
    {
        cout << "round #" << i+1 << ": ";
        while (!(cin >> golf[i])) {
            cin.clear();     // 입력을 초기화화
            while (cin.get() != '\n')
                continue;    // 불량 입력을 제거한다.
            cout << "골프 점수를 입력: ";
        }
    }
// calculate average
    double total = 0.0;
    for (i = 0; i < Max; i++)
        total += golf[i];
// report results
    cout << total / Max << " = average score "
            << Max << " rounds\n";
    
    return 0; 
}
```
출력 결과
```
골프 점수를 입력하시오.
총 5 라운드 점수를 입력해야 합니다.
round #1: 65
round #2: ㅂ
골프 점수를 입력: 45
round #3: 65
round #4: 78
round #5: ㅈ
골프 점수를 입력: 45
59.6 = average score 5 rounds
```

사용자가 숫자를 입력하면 true가 되고 배열에 저장한다 그러나 문자를 입력하면 

false가 되고 배열에 값이 저장되지 않는다.

## 6.8 간단한 파일 입력/출

### 텍스트 I/O와 텍스트 파일

cin이 동일한 입력 행을 서로 다른 데이터형에 대해 처리하는 방법

샘플 입력 행 = 38.5 19.2

* char
```
char n;
cin >> n;
```
    입력 행에 있는 첫 문자가 매개변수에 대입된다.
    이 경우에 첫 문자는 숫자 3이고 이에 해당하는 문자 코드가 ch에 대입된다.
    입력과 목적지가 둘 다 문자다.
    그 입력 구문이 끝난 후에 입력 큐에 있는 다음 문자는 숫자 8이고 다음 입력 동작에 적용된다.

* int
```
int n;
cin >> n;
```
    첫 문자가 나올 때까지 읽는다.
    3,8읽고 소수점을 입력 큐에 남겨둔다 그리고 두 문자가 숫치 값 38에 해당한다고 계산하
    28에 해당하는 바이너리 코드를 n에 대입한다

* double
```
double n;
cin >> n;
```
첫 문자가 나올 때까지 읽는다 3 , 8 , . ,5 읽고 빈칸을 큐에 남겨둔다

* char []
```
char word[50];
cin >> word;
```
빈칸 문자가 나올 때까지 읽는다

5까지 일고 다음에 읽을 문자로 빈칸을 남겨두고 3, 8, . , 5 를 배열에 저장하고

끝에 널 문자를 추가 변환은 없다.

* char getline()

cin은 개행 문자가 나올 때까지 읽는다 2까지 읽고 끝에 널을 추가


요약

    모든 입력이 텍스트로 시작한다

### 텍스트 파일에 쓰기

* fstream 헤더 파일을 포함시킨다
* 출력을 처리하는  ofstream클래스를 정의한다
* 하나 이상의 ofstream 변수 또는 객체 선언
* std 이름공간 지정
* ofstream 객체와 특정 파일을 연결시킬 필요가 있다. ex) open() 메서드
* 파일을 다루는 작업이 끝나면 close() 메서드를 사용
* <<연산자와 함께 사용하여 다양한 유형의 데이터를 출력

```
ofstream outFile;
ofstream fout;
outFile.open("fish.txt");
char filename[50];
cin >> filename;
fout.open(filename);
outFile.close();

```

요약

1. fstream 헤더 파일을 포함시킨다
2. ofstream 객체 생성
3. ofstream 객체를 파일에 연결
4. ofstream 객체를 cout 과 동일한 방식으로 사용한다

### 텍스트 파일 읽기

1. 텍스트 파일을 열기 위해 `fstream` 클래스의 인스턴스를 생성합니다.
2. `fstream` 클래스의 `open()` 메서드를 사용하여 파일을 열고, 읽기 모드로 열어야 합니다.
3. 파일에서 한 줄씩 읽어들입니다.
4. 읽어들인 줄을 출력합니다.
5. 파일을 닫습니다.

다음은 텍스트 파일을 읽는 코드입니다.

```
#include <iostream>
#include <fstream>

using namespace std;

int main() {
  fstream fs("file.txt");

  string line;

  while (getline(fs, line)) {
    cout << line << endl;
  }

  fs.close();

  return 0;
}
```

이 코드는 `file.txt` 파일을 열고, 한 줄씩 읽어들여 출력합니다.

 ifstream을 사용하는 단계.

1. ifstream 클래스의 인스턴스를 생성합니다.
2. ifstream 클래스의 open() 메서드를 사용하여 파일을 열고, 읽기 모드로 열어야 합니다.
3. 파일에서 한 문자씩 읽어들입니다.
4. 읽어들인 문자를 출력합니다.
5. 파일을 닫습니다.

다음은 ifstream을 사용하여 텍스트 파일을 읽는 코드입니다.

```
#include <iostream>
#include <fstream>

using namespace std;

int main() {
  ifstream fs("file.txt");

  char ch;

  while (fs.get(ch)) {
    cout << ch;
  }

  fs.close();

  return 0;
}
```

이 코드는 `file.txt` 파일을 열고, 한 문자씩 읽어들여 출력합니다.

# 7장 함수 -C++의 프록래밍 모듈

```
// calling.cpp -- defining, prototyping, and calling a function
#include <iostream>

void simple();    // 함수 원형

int main()
{
    using namespace std;
    cout << "main() 에서 simple() 함수를 호출합니다. :\n";
    simple();     // 함수호출출
	cout << "main() 이 simple() 함수와 종료됩니다. .\n";
    // cin.get();
    return 0;
}

// function definition
void simple()
{
    using namespace std;
    cout << "여기는 simple함수입니다.\n";
}
```
출력물
```
main() 에서 simple() 함수를 호출합니다. :
여기는 simple함수입니다.
main() 이 simple() 함수와 종료됩니다. .
```

### 함수 정의

1. 리턴값이 있는 함수
2. 리턴값이 없는 함수


**리턴값이 있는 함수**

리턴값이 있는 함수는 함수의 실행 결과를 값으로 반환하는 함수입니다. 리턴값이 있는 함수는 다음과 같이 작성됩니다.

```cpp
// 리턴값이 있는 함수의 예
int sum(int a, int b) {
  return a + b;
}
```

이 함수는 2개의 정수의 합을 반환합니다. 이 함수를 사용하려면 다음과 같이 호출합니다.

```cpp
// 함수 호출
int result = sum(1, 2);
```

이 코드는 `3`을 출력합니다.

**리턴값이 없는 함수**

리턴값이 없는 함수는 함수의 실행 결과를 값으로 반환하지 않는 함수입니다. 리턴값이 없는 함수는 다음과 같이 작성됩니다.

```cpp
// 리턴값이 없는 함수의 예
void print_hello_world() {
  std::cout << "Hello, World!";
}
```

이 함수는 문자열 "Hello, World!"를 출력합니다. 이 함수를 사용하려면 다음과 같이 호출합니다.

```cpp
// 함수 호출
print_hello_world();
```

이 코드는 `Hello, World!`를 출력합니다.

리턴값이 있는 함수는 함수의 실행 결과를 다른 함수에 전달하거나 변수에 저장하는 데 사용할 수 있습니다. 

리턴값이 없는 함수는 함수의 실행 결과를 출력하거나 다른 작업을 수행하는 데 사용할 수 있습니다.

* 리턴값이 있는 함수는 typeName형으로 변환될 수 있어야 한다
  ( 리턴형이 double인데 함수가 int 형 표현식을 리턴한다면 그 int 형 값은 double 형으로 변환된다.)
* 배열은 리턴값으로 사용할 수 없다.(나머지는 가능)

### 함수 원형과 함수 호출

```cpp
// protos.cpp -- using prototypes and function calls
#include <iostream>
void cheers(int);       // 함수원형 : 리턴값이 없다.
double cube(double x);  // 함수원형 : 리턴값이 있있다.
int main()
{
    using namespace std;
    cheers(5);          // 함수 호출
    cout << "하나의 수를 입력하시오: ";
    double side;
    cin >> side;
    double volume = cube(side);    // function call
    cout << "한변의 길이가가 " << side <<"센티미터인 정육면체의 부피는 ";
    cout << volume << " 센티미터 제곱입니다.\n";
    cheers(cube(2));    // 원형 보호에 의해 작동한다.
    // cin.get();
    // cin.get();
    return 0;
}

void cheers(int n)
{
    using namespace std;
    for (int i = 0; i < n; i++)
        cout << "Cheers! ";
    cout << endl;
}

double cube(double x)
{
    return x * x * x; 
}
```
출력물
```
Cheers! Cheers! Cheers! Cheers! Cheers! 
하나의 수를 입력하시오: 5
한변의 길이가가 5센티미터인 정육면체의 부피는 125 센티미터 제곱입니다.
Cheers! Cheers! Cheers! Cheers! Cheers! Cheers! Cheers! Cheers!
```
#### 함수 원형이 필요한 이유

함수 원형이 필요한 이유는 컴파일러가 함수를 올바르게 컴파일하고 실행할 수 있도록 함수를 선언하는 데 사용되기 때문입니다.

함수 원형은 함수의 이름, 매개변수의 개수와 타입, 반환 값의 타입을 명시합니다. 

함수 원형이 없으면 컴파일러는 함수의 이름과 매개변수의 개수만 알 수 있습니다.

따라서 컴파일러는 함수의 반환 값의 타입을 알 수 없고, 함수를 호출할 때 올바른 값을 전달하지 못할 수 있습니다. 

이로 인해 컴파일 오류가 발생하거나 프로그램이 실행되지 않을 수 있습니다.

```
예를 들어, `cheers` 함수는 매개변수로 정수를 받아서 "Cheers!"를 출력합니다.
 `cube` 함수는 매개변수로 실수를 받아서 그 실수를 제곱한 값을 반환합니다.
 `main` 함수는 `cheers` 함수를 호출하여 5를 인자로 전달하고,
 `cube` 함수를 호출하여 2를 인자로 전달합니다.
 `cheers` 함수는 정수를 인자로 받고, `cube` 함수는 실수를 인자로 받습니다.
 따라서 함수 원형을 선언하지 않으면 컴파일러는 함수를 올바르게 컴파일할 수 없습니다.

```
함수 원형을 선언하면 컴파일러가 함수를 올바르게 컴파일하고 실행할 수 있습니다.

따라서 함수를 호출하기 전에 함수 원형을 선언하는 것이 좋습니다.

* 함수 원형은 함수를 호출하는 사용자에게 다음과 같은 이점을 제공합니다.

1. 함수를 호출할 때 올바른 값을 전달할 수 있습니다.
2. 함수를 호출할 때 컴파일 오류를 방지할 수 있습니다.
3. 함수의 반환 값을 사용할 수 있습니다.
4. 함수의 매개변수의 타입을 알 수 있습니다.
5. 함수 원형을 사용하면 함수를 보다 안전하고 효율적으로 사용할 수 있습니다.

## 7.2 함수 매개변수와 값으로 전달하기

형식 매개변수 : 전달되는 값을 넘겨받는 데 쓰이는 변수

실제 매개변수 : 함수에 전달되는 값

### 여러 개의 매개변수

함수는 하나 이상의 매개변수를 가질 수 있다. 함수 호출에서 매개변수들은 콤마로 분리한다.

```
n_chars('R' , 25);
void n_chars(float a, float b); // 각 변수를 독립적으로 선언
void n_chars(float a, b);       // 결합이 허용되지 않는다.

void n_chars(float a, int b);   // 함수 원형 스타일 1
void n_chars(float , int );     // 함수 원형 스타일 2 ( 보기 어렵다)
```

### 두 개의 매개변수를 사용하는 또 다른 함수

지역 변수를 사용하는 방법은 다음과 같습니다.

```c++
// 함수의 선언
void my_function(int num);

// 함수의 정의
void my_function(int num) {
  // 지역 변수 선언
  int local_num = num;

  // 지역 변수 사용
  std::cout << local_num << std::endl;
}

// 함수의 호출
int main() {
  int num = 10;
  my_function(num);
}
```

이 코드는 `my_function` 함수를 호출하여 10을 인자로 전달합니다.

`my_function` 함수는 인자로 받은 값을 지역 변수 `local_num`에 저장하고, `local_num`의 값을 출력합니다.

함수에서 형식 매개변수가 아니라 지역 변수를 사용하면 다음과 같은 이점이 있습니다.

* 함수의 효율성이 높아집니다.
* 함수의 코드가 간결해집니다.
* 함수의 오류 가능성이 줄어듭니다.

## 7.3 함수와 배열

```
int sum_arr(int arr[], int n)// arr = 배열 이름 , n = 크기
```

대괄호 arr 가 배열이라는 것을 나타내고 

대괄호 안이 비어 있는 것은 

어떠한 크기의 배열도 사용할 수 있다는 것을 뜻하는 것처럼 보이지만

*arr은 사실 배열이 아니라 포인터이다*






